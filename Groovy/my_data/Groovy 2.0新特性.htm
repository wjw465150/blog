<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Groovy 2.0新特性</title>
<meta name="GENERATOR" content="WinCHM">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
html,body { 
	/* Default Font */
	font-family: 宋体, Arial, Helvetica, sans-serif;
	font-size: 10pt;
}
</style>

</head>

<body>
<H1 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: bold 26px arial; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><A 
style="COLOR: rgb(51,51,51); TEXT-DECORATION: " 
href="http://www.infoq.com/cn/articles/new-groovy-20" rel=permalink>Groovy 
2.0新特性</A></H1>
<P class=info 
style="LIST-STYLE-TYPE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; FONT: 12px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">作者<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><STRONG 
style="COLOR: rgb(28,73,123); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2px; PADDING-RIGHT: 2px"><A 
class="editorlink f_taxonomyEditor" 
style="COLOR: rgb(28,73,123) !important; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2px; TEXT-DECORATION: ; PADDING-RIGHT: 2px" 
href="http://www.infoq.com/cn/author/Guillaume-Laforge">Guillaume 
Laforge</A><SPAN class=Apple-converted-space>&nbsp;</SPAN></STRONG>译者<STRONG 
style="COLOR: rgb(28,73,123); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2px; PADDING-RIGHT: 2px"><A 
class="editorlink f_taxonomyTranslator" 
style="COLOR: rgb(28,73,123) !important; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2px; TEXT-DECORATION: ; PADDING-RIGHT: 2px" 
href="http://www.infoq.com/cn/author/%E8%83%A1%E4%BC%9F%E7%BA%A2"><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>胡伟红</A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN></STRONG>发布于 2012年10月19日</P>
<DL class=tags2 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 0px; PADDING-TOP: 0px; FONT: 12px/19px 'Trebuchet MS'; PADDING-LEFT: 0px; MARGIN: 0px 0px 3px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">
  <DT class=community 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px">领域<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>
  <DD 
  style="FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px"><A 
  onclick="try {CategoryPopup.showPopup(this);} catch(e) {}; return false;" 
  id=6,820 class=f_taxonomy style="COLOR: rgb(49,133,40); TEXT-DECORATION: " 
  href="http://www.infoq.com/cn/development" name=development>语言 &amp; 
  开发</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>
  <DT class=topics 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 15px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px">主题<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>
  <DD 
  style="FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px"><A 
  onclick="try {CategoryPopup.showPopup(this);} catch(e) {}; return false;" 
  id=903 class=f_taxonomy style="COLOR: rgb(49,133,40); TEXT-DECORATION: " 
  href="http://www.infoq.com/cn/groovy" name=groovy>Groovy</A><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>,<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>
  <DD 
  style="FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px"><A 
  onclick="try {CategoryPopup.showPopup(this);} catch(e) {}; return false;" 
  id=739 class=f_taxonomy style="COLOR: rgb(49,133,40); TEXT-DECORATION: " 
  href="http://www.infoq.com/cn/java" name=java>Java</A><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>,<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>
  <DD 
  style="FONT-WEIGHT: bold; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; DISPLAY: inline; PADDING-RIGHT: 0px"><A 
  onclick="try {CategoryPopup.showPopup(this);} catch(e) {}; return false;" 
  id=832 class=f_taxonomy style="COLOR: rgb(49,133,40); TEXT-DECORATION: " 
  href="http://www.infoq.com/cn/dynamic_languages" 
  name=dynamic_languages>动态语言</A></DD></DL>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">新发布的Groovy2.0为这门语言带来了关键的静态特性：<B>静态类型检查</B>和<B>静态编译</B>；采用了JDK 
7相关的改进：<B>Project Coin语法增强</B>和<B>新支持的“invoke dynamic” 
JVM指令</B>；同时，<B>提高了模块化</B>。我们将在这篇文章中了解这些新特性的详情。</P>
<DIV class=content-sidebar-wide 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">&nbsp;</DIV>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">面向动态语言的“静态主题”</H2>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态类型检查</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy天生而且永远都是动态语言。但Groovy也常被当作"Java脚本语言"，或是“更好的Java”（即限制更少且功能更强的Java）。实际上，许多Java开发者将Groovy作为一种扩展语言使用或嵌入到自己的Java应用中，如编写表现力更强的业务规则、为不同客户进一步定制应用等。对于这种面向Java的使用场景，开发者并不需要这门语言提供的所有动态能力，他们通常期望能从Groovy编译器得到跟javac编译器一样的反馈。特别是，他们希望得到编译错误（而非运行时错误），如变量或方法名的拼写错误、错误的类型赋值等。这就是Groovy 
2支持<B>静态类型检查</B>的原因。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">指出明显的拼写错误</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态类型检查器建立在Groovy已有、强大的AST（抽象语法树）之上，不熟悉它们的开发者可以将其视为一种利用注解触发的可选编译器插件。作为可选特性，不需要它时，Groovy不会强制你使用。要触发静态类型检查，只需在方法或类上使用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked</CODE>注解就可以在你期望的粒度级别打开检查。让我们首先看一个示例：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR><B>void</B> someMethod() {}<BR><BR>@TypeChecked<BR><B>void</B> test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 找不到匹配的sommeeMethod()</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;sommeeMethod()<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> name = "Marion"<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 没有声明变量naaammme</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;println naaammme<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">我们用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked</CODE>注解了<CODE 
style="FONT: 12px/15px 'Courier New', Courier">test()</CODE>方法，它告诉Groovy编译器在编译时对指定的方法进行静态类型检查。我们试图调用带有明显拼写错误的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">someMethod()</CODE>，并打印另一个拼错的name变量，编译器会分别抛出2个编译错误，因为找不到对应的方法和变量声明。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">检查赋值和返回值</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态类型检查器还会验证返回类型和赋值是否一致：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked<BR><B>Date</B> test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 不能把Date赋给 </I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// int类型的变量</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>int</B> object = <B>new</B> Date()<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;String[] letters = ['a', 'b', 'c']<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 不能把String类型的值赋给 </I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// Date类型的变量</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;Date aDateVariable = letters[0]<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 无法在返回Date类型的方法中 </I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 返回String类型的值</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B> "today"<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在这个示例中，编译器会抱怨这样的事实：你没法把<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Date</CODE>赋给<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>变量，也没法返回<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>来取代方法签名中指定的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Date</CODE>。正中间脚本引起的编译错误也很有趣，因为它不仅抱怨了错误的赋值，而且还因为它展示了动态类型推断的能力，这当然是由于类型检查器知道<CODE 
style="FONT: 12px/15px 'Courier New', Courier">letters[0]</CODE>是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>类型，因为我们正在处理一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>数组。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">类型推断的更多细节</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">既然谈到了类型推断，那我们就看看它的一些其他表现形式。我们曾说过类型检查器会跟踪返回类型和值：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked<BR><B>int</B> method() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>if</B> (<B>true</B>) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 编译错误：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 无法在返回int类型的方法中</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 返回String类型的值</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'String'<BR>&nbsp;&nbsp;&nbsp;&nbsp;} <B>else</B> {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;42<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">若方法返回原始类型的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>值，类型检查器还能够检查出不同结构的返回值，如<CODE 
style="FONT: 12px/15px 'Courier New', Courier">if/else</CODE>分支、<CODE 
style="FONT: 12px/15px 'Courier New', Courier">try/catch</CODE>块或<CODE 
style="FONT: 12px/15px 'Courier New', Courier">switch/case</CODE>块。在该示例中，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">if/else</CODE>块的一个分支试图返回一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>值而非原始类型的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>，这时编译器就开始抱怨了。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">常见的类型转换依然可用</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">但静态类型检查器不会对Groovy支持的某些自动类型转换进行抱怨。例如，对于返回<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String、boolean</CODE>或<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Class</CODE>的方法签名，Groovy会自动将返回值转换到这些类型：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked<BR><B>boolean</B> booleanMethod() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;"non empty strings are evaluated to true"<BR>}<BR><BR><B>assert</B> booleanMethod() == <B>true</B><BR><BR>@TypeChecked<BR>String stringMethod() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 调用toString()将StringBuilder转换成String</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B> StringBuilder() &lt;&lt; "non empty string"<BR>}<BR><BR><B>assert</B> stringMethod() <B>instanceof</B> String<BR><BR>@TypeChecked<BR><B>Class</B> classMethod() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 会返回java.util.List类</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;"java.util.List"<BR>}<BR><BR><B>assert</B> classMethod() == List</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态类型检查器的智能足以完成<B>类型推断</B>：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked<BR><B>void</B> method() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> name = " Guillaume "<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 判断出是String类型（就算它是在GString中）</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;println "NAME = ${name.toUpperCase()}"<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 支持Groovy GDK方法</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// （也支持GDK操作符重载）</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;println name.trim()<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>int</B>[] numbers = [1, 2, 3]<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 元素n是int</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>for</B> (<B>int</B> n <B>in</B> numbers) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;println <BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">尽管<CODE 
style="FONT: 12px/15px 'Courier New', Courier">name</CODE>变量是用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">def</CODE>定义的，但类型检查器还是知道它是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>类型。接下来，当这个变量被插入用在string中时，它知道name变量能调用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String的toUpperCase()</CODE>方法，或者之后的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">trim()</CODE>方法，该方法是由Groovy 
Development Kit添加用来装饰<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>类的。最后，当循环原始的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>数组时，它还知道数组中的元素明显就是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">动态特性和静态化类型方法的混合使用</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">记住一点很重要：使用静态类型检查工具会限制你能在Groovy中使用的特性。大多数运行时动态特性是不允许的，因为它们没法在编译时被静态类型检查。因此，通过类型的元类（metaclass）在运行时添加一个新方法是不允许的。但是，当你需要使用一些特殊的动态特性时，比如Groovy的构建器（builder），只要愿意，你可以选择不使用静态类型检查。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked</CODE>注解可用于类或方法级别。因此，要是想对整个类进行类型检查，就把它用在类上，若只想对某些方法进行类型检查，可以把它用在那些方法上。此外，若想对所有内容进行类型检查，但排除某个特殊方法，你可以对被排除方法使用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked(TypeCheckingMode.SKIP)</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>- 或简化版本<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked(SKIP)</CODE>，前提是你静态导入了相关枚举。以下脚本说明了这种情况，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">greeting()</CODE>方法需要类型检查，而<CODE 
style="FONT: 12px/15px 'Courier New', Courier">generateMarkup()</CODE>方法不需要：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><B>import</B> groovy.xml.MarkupBuilder<BR><BR><I>// 这个方法和它的代码要进行类型检查</I><BR>@TypeChecked<BR>String greeting(String name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;generateMarkup(name.toUpperCase())<BR>}<BR><BR><I>// 这个方法不需要类型检查</I><BR><I>// 并且你可以使用像markup builder这样的动态特性</I><BR>String generateMarkup(String name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> sw =<B>new</B> StringWriter()<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B> MarkupBuilder(sw).html {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div name<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;sw.toString()<BR>}<BR><BR><B>assert</B> greeting("Cédric").contains("&lt;div&gt;CéDRIC&lt;/div&gt;")</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">类型推断和instanceof检查</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">当前的Java发行版不支持通用的类型推断；因此今天我们发现很多地方的代码往往相当冗长并且结构混乱。这掩盖了代码的意图，而且没有强大的IDE支持也很难写代码。这是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">instanceof</CODE>检查的应用场景：你经常会在<CODE 
style="FONT: 12px/15px 'Courier New', Courier">if</CODE>条件中使用instanceof检查值的类，并且在<CODE 
style="FONT: 12px/15px 'Courier New', Courier">if</CODE>块之后，你必须使用对象转型（cast）才能使用这个对象值的方法。用一般的Groovy代码，结合新的静态类型检查模式，你可以彻底摆脱那些对象转型。</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><B>import</B> groovy.xml.MarkupBuilder<BR><BR>@TypeChecked<BR>String test(Object val) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>if</B> (val <B>instanceof</B> String) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 不同于Java的写法：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// return ((String)val).toUpperCase()</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val.toUpperCase()<BR>&nbsp;&nbsp;&nbsp;&nbsp;} <B>else</B> <B>if </B>(val <B>instanceof</B> Number) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 不同于Java的写法：</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// return ((Number)val).intValue().multiply(2)</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val.intValue() * 2<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}<BR><BR><B>assert</B> test('abc') == 'ABC'<BR><B>assert</B> test(123) == '246'</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在上面的示例中，静态类型检查器知道参数val在<CODE 
style="FONT: 12px/15px 'Courier New', Courier">if</CODE>块中是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>类型，在else if块中是<CODE 
style="FONT: 12px/15px 'Courier New', Courier"><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>Number</CODE>，无需任何转换。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">最低上限</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态类型检查器在类型推断方面走得更远，从某种意义上讲它对你的对象类型了解更精细。考虑下面的代码：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR><I>// 推断返回类型：</I><BR><I>// 一个可比较和可序列化的数字列表</I><BR>@TypeChecked test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;// 一个整型和一个BigDecimal<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>return</B> [1234, 3.14]<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在这个示例中，凭直觉，我们返回了一组数字：一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Integer</CODE>和一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">BigDecimal</CODE>。但是静态类型检查器计算了我们所说的<I>“最低上限（lowest 
upper 
bound）”</I>，它实际上是一个数字列表，而且是可序列化和可比较的。用标准Java类型符号不可能表示该类型，但如果我们有一些类似与操作（&amp;）的交集操作符，它看起来就像<CODE 
style="FONT: 12px/15px 'Courier New', Courier">List&lt;Number &amp; Serializable 
&amp; Comparable&gt;。</CODE></P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">流式转型（Flow 
typing）</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">尽管其实不应该将这种做法视为好实践，但有时开发者会使用相同的无类型变量来存储不同类型的值。看看方法体：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> var = 123 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 推断出的类型是int</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;var = "123" &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>// 用一个String给var赋值</I><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;println var.toInteger() &nbsp;&nbsp;<I>// 没问题，不需要转型</I><BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;var = 123<BR>&nbsp;&nbsp;&nbsp;&nbsp;println var.toUpperCase() <I>// 出错了，var是int型！</I><BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><CODE 
style="FONT: 12px/15px 'Courier New', Courier">var</CODE>变量一开始被初始化为<CODE 
style="FONT: 12px/15px 'Courier New', Courier">int</CODE>。然后，被赋给一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>。<I>"流式转型（flow 
typing）"</I>算法根据赋值流程知道变量现在持有一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>，所以静态类型检查器会乐于接受由Goovy添加到<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>上的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">toInteger()</CODE>方法。接下来，一个数字被放回到var变量中，但是紧接着调用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">toUpperCase()</CODE>时，类型检查器将抛出一个编译错误，因为<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Integer</CODE>上没有<CODE 
style="FONT: 12px/15px 'Courier New', Courier">toUpperCase()</CODE>方法。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">对于被共享给对其感兴趣的闭包中的变量，流式转型算法有些特殊的情况。当局部变量被定义该变量的方法中的闭包引用时，会发生什么？看看这个示例：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR>@TypeChecked test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> var = "abc"<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> cl = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>if</B> (<B>new</B> Random().nextBoolean()) var = <B>new</B> Date()<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;cl()<BR>&nbsp;&nbsp;&nbsp;&nbsp;var.toUpperCase() // 编译错误！<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">局部变量<CODE 
style="FONT: 12px/15px 'Courier New', Courier">var</CODE>被赋值为<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>，但接着，若某个随机值为真，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">var</CODE>可能会被赋值为<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Date</CODE>。一般情况下，只有在运行时我们才确切知道闭包的if语句中的条件为真还是假。因此，编译器不可能在编译时知道<CODE 
style="FONT: 12px/15px 'Courier New', Courier">var</CODE>现在是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>还是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Date</CODE>。这就是编译器对于<CODE 
style="FONT: 12px/15px 'Courier New', Courier">toUpperCase()</CODE>调用抱怨的原因，因为它无法推断变量包含的是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>。这个例子虽略显做作，但是下面有一些有趣的例子：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.TypeChecked<BR><BR><B>class</B> A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <B>void</B> foo() {} }<BR><B>class</B> B <B>extends</B> A { <B>void</B> bar() {} }<BR><BR>@TypeChecked test() {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> var = <B>new</B> A()<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>def</B> cl = { var = <B>new</B> B() }<BR>&nbsp;&nbsp;&nbsp;&nbsp;cl()<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// var起码是个A的实例</I><BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>// 所以我们允许调用foo()方法 </I><BR>&nbsp;&nbsp;&nbsp;&nbsp;var.foo()<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在上面的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">test()</CODE>方法中，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">var</CODE>被赋予<CODE 
style="FONT: 12px/15px 'Courier New', Courier">A</CODE>的一个实例，然后在闭包中被赋予<CODE 
style="FONT: 12px/15px 'Courier New', Courier">B</CODE>的一个实例，因此我们至少可推断出var类型<CODE 
style="FONT: 12px/15px 'Courier New', Courier">A</CODE>。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">所有这些添加到Groovy编译器中的检查都是在编译时完成的，但是生成的字节码像往常一样仍是相同的动态码 
- 在行为上根本没变。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">由于编译器现在知道你程序中类型方面的很多事情，它向许多有趣的能力敞开了大门：静态编译那些被类型检查的代码怎样？除了其他优势，一个明显优势是生成的字节码将更接近于由javac编译器自己生成的字节码，让静态编译过的Groovy代码跟纯Java代码一样快。在下一节，我们将了解更多关于Groovy静态编译的内容。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">静态编译</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">正如我们将在以下关于向JDK 
7靠齐的章节中看到的，Groovy 2.0支持JVM新的<I>"invoke 
dynamic"</I>指令及其相关API，它们简化了Java平台上动态语言的开发并为Groovy的动态调用带来了额外的性能提高。可不幸的是，在本文撰写时，JDK 
7尚未被部署于生产环境，因而并非所有人都有机会运行最新版本。所以期待性能改进的开发者若没法运行在JDK 7上，就不会在Groovy 
2.0中看到太多的改变。所幸，Groovy开发团队考虑到了这些开发者（除了其他改进之外）会对性能改进感兴趣，其手段就是允许类型检查后的代码代码可被静态编译。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">废话少说，让我们现在就亲手试试新的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@CompileStatic</CODE>注解：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>import</B> groovy.transform.CompileStatic<BR><BR>@CompileStatic<BR><B>int</B> squarePlusOne(<B>int</B> num) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;num * num + 1<BR>}<BR><BR><B>assert</B> squarePlusOne(3) == 10</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">这次使用的是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@CompileStatic</CODE>，而非<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked</CODE>，并且你的代码会被静态编译，同时生成的字节码非常像javac的字节码，运行速度一样。就像<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@TypeChecked</CODE>注解，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@CompileStatic</CODE>能注解类和方法，<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@CompileStatic(SKIP)</CODE>可以让某个方法在其所属类被<CODE 
style="FONT: 12px/15px 'Courier New', Courier">@CompileStatic</CODE>标记时不被静态编译。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">生成类javac（javac-like）字节码的另一好处是那些被注解的方法的字节码大小会比通常Groovy为动态方法生成的字节码的大小要小，因为要支持Groovy的动态特性，动态场景下的字节码包含了调用Groovy运行时系统的额外指令。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">最后一点值得注意的是，框架或库代码作者可使用静态编译，这有助于避免当代码库中多个部分使用动态元编程时的负面影响。像Groovy这类语言中可用的动态特性给开发者带来了极强的能力和灵活性，但鉴于元编程特性是动态发挥作用的，若不加注意，不同的假设会存在于系统的不同部分，由此产生意想不到的后果。举一个例子（虽然有点刻意为之），假设你在使用两个不同的库时发生的情景，两个库都给你的核心类添加了一个名字相似但实现不同的方法。什么行为是期望的？有经验的动态语言使用者可能之前就见过这个问题，并且可能听说它被称为<I>“猴子补丁（monkey 
patching，译注：在不改变原始代码的情况下扩展或修改动态语言运行时代码的方法）”</I>。若能静态编译代码库中的部分代码 - 那些不需要动态特性的代码 - 
保护了你不受猴子补丁的影响，因为静态编译后的代码不会经过Groovy的动态运行系统。尽管语言的动态运行时方面不允许出现在静态编译环境中，但所有常用的AST转换机制还会像以前一样工作良好，因为多数AST转换机制也是在编译时施展它们的魔法。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">说到性能，Groovy的静态编译代码通常会或多或少跟javac的一样快。在开发团队使用的一些微基准测试中，有些情况下性能相同，而有时则可能稍慢。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在以前，由于Java和Groovy透明无缝的集成，我们过去常建议开发者优化Java的hotspot例程以获得进一步改进性能，但是现在，有了这个静态编译选择，情况变了，那些想完全用Groovy开发项目的人们也能这样做了。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Java 
7和JDK 7主题</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy编程语言的语法其实来自于Java语法本身，但很明显，Groovy提供了额外漂亮的便捷方法让开发者生产力更高。让Java开发者熟悉的语法一直以来都是这个项目的重要卖点，并且被广泛接纳，这得益于平坦的学习曲线。我们当然也期望Groovy用户和新人也能从Java 
7增加的<I>"Project Coin"</I>所提供的一些语法改进中受益。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">除了语法，JDK 
7还为它的API带来了一些有趣的新事物，这是长久以来的第一次，它甚至添加了一个被称为<I>"invoke 
dynamic"</I>的字节码指令，它旨在让实现者更容易地开发他们的动态语言和获得更高的性能。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Project 
Coin语法增强</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">从第一天开始（这要从2003年说起！），Groovy就拥有几处建立在Java之上的语法增强和特性。例如，人们可以想到的是闭包，以及<CODE 
style="FONT: 12px/15px 'Courier New', Courier">switch/case</CODE>语句中可使用的不仅限于离散值，而Java 
7中只是多了能使用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">多个String</CODE>。所以一些Project 
Coin语法增强，比如switch中的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">多个String</CODE>，已经在Groovy中了。然而，有些增强是新的，如二进制字面量、数字字面量中的下划线或者多catch块，Groovy 
2都支持。唯一漏掉的Project Coin增强是"try with resources"结构，对于它，Groovy通过Groovy Development 
Kit丰富的API提供了多个替代解决方案。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">二进制字面量</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在Java 
6及之前版本，以及Groovy中，数字可以表示成十进制、八进制和十六进制，而在Java 7和Groovy 2中，你可以使用以“0b”做前缀的二进制符号：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>int</B> x = 0b10101111<BR><B>assert</B> x == 175<BR><BR><B>byte</B> aByte = 0b00100001<BR><B>assert</B> aByte == 33<BR><BR><B>int</B> anInt = 0b1010000101000101<BR><B>assert</B> anInt == 41285</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">数字字面量中的下划线</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">当写长变量数字时，很难用肉眼分辨出一些数字是如何分组聚合在一起的，例如千位分组，单词等等。通过允许在数字字面量中放置下划线，就很容易区分这些分组了：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>long</B> creditCardNumber = 1234_5678_9012_3456L<BR><B>long</B> socialSecurityNumbers = 999_99_9999L<BR><B>double</B> monetaryAmount = 12_345_132.12<BR><B>long</B> hexBytes = 0xFF_EC_DE_5E<BR><B>long</B> hexWords = 0xFFEC_DE5E<BR><B>long</B> maxLong = 0x7fff_ffff_ffff_ffffL<BR><B>long</B> alsoMaxLong = 9_223_372_036_854_775_807L<BR><B>long</B> bytes = 0b11010010_01101001_10010100_10010010</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">多catch块</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">当捕获到异常时，我们通常会复制两个或更多的异常块，因为我们想用同样的方式处理它们。解决方法是，要么在它自己的方法中分离出通用的内容，或者一种更丑陋的方式就是通过捕获<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Exception</CODE>（或者更糟的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">Throwable</CODE>）完成一个捕获所有异常的方法。用多catch块，我们能定义要用一个catch块捕获和处理的多种异常：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>try</B> {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>/* ... */</I><BR>} <B>catch</B>(IOException | NullPointerException e) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<I>/* 一个代码块处理2个异常 */</I><BR>}</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Invoke 
Dynamic的支持</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">正如本文之前提到的，JDK 
7带来了一个被称为<I>"invoke 
dynamic"</I>的新字节码指令以及相关的API。其目的是帮助动态语言实现者在Java平台之上打造自己的语言，实现手段则是：简化动态方法的调用路径，定义可缓存动态方法的<I>"call 
site"</I>，作为方法指针的<I>"method handles"</I>，存储类对象中各种元数据的<I>"class 
values"</I>，以及其他一些内容。不过事先提醒，尽管承诺性能改进，但"invoke 
dynamic"在JVM内部还没有完全优化，也并不总能提供最好的性能，但随着一步步的更新，优化就会到来。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy带来了它自己的实现技术，用“call 
site缓存”加速方法的选择和调用，用元类注册库存储元类（类的等价动态运行时），执行跟Java一样快的原生原始计算（native primitive 
calculation），等等。但随着“invoke 
dynamic”的问世，我们将重新把Groovy的实现置于这些API和JVM字节码指令之上，以获得性能的改进和简化我们的代码库。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">如果有幸运行JDK 
7，你就能使用已经编译进"invoke dynamic"支持的Groovy JAR的新版本。很容易辨认那些JAR，因为它们名字都含有"-indy"区分。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">启用invoke 
dynamic支持</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">然而，要想利用"invoke 
dynamic"，光用"indy"JAR编译你的Groovy代码还不够。鉴于此，使用“groovyc”编译器或者“groovy”命令时，你必须使用--indy标记。这也就意味着，就算用的是indy 
JAR，你仍可以面向JDK 5或6进行编译。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">同样的，如果你正在使用groovyc 
Ant task编译你的项目，你还可以指定indy属性：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">...<BR>&lt;taskdef name="groovyc"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classname="org.codehaus.groovy.ant.Groovyc"<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classpathref="cp"/&gt;<BR>...<BR>&lt;groovyc srcdir="${srcDir}" destdir="${destDir}" <B>indy=</B>"<B>true</B>"&gt;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;classpath&gt;<BR>...<BR>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/classpath&gt;<BR>&lt;/groovyc&gt;<BR>...</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy 
Eclipse Maven编译器插件还没有更新包含Groovy 2.0支持，但也快了。对于GMaven插件的用户，尽管已经可以配置插件使用Groovy 
2.0，目前还没有支持invoke dynamic的标志位。同样，GMaven很快也会有这方面的更新。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">当在Java应用中集成Groovy时，用<CODE 
style="FONT: 12px/15px 'Courier New', Courier">GroovyShell</CODE>，你还可以通过给<CODE 
style="FONT: 12px/15px 'Courier New', Courier">GroovyShell</CODE>构造函数传递一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">CompilerConfiguration</CODE>实例来激活invoke 
dynamic支持，在<CODE 
style="FONT: 12px/15px 'Courier New', Courier">GroovyShell</CODE>上可以访问和设置优化选项：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">CompilerConfiguration config = <B>new</B> CompilerConfiguration();<BR><B>config.getOptimizationOptions().put(</B>"<B>indy</B>"<B>, true);</B><BR><B>config.getOptimizationOptions().put(</B>"<B>int</B>"<B>, false);</B><BR>GroovyShell shell = <B>new</B> GroovyShell(config);</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">由于invokedynamic被期望成能够完全替代动态方法分发，禁用那些为了优化边缘情况而生成额外二进制码的原始优化（primitive 
optimizations）是有必要的。即使在某些情况下它比激活原始优化慢，JVM的未来版本将会对JIT有所改进，它将有能力内联（inlining）多数调用并去除那些没必要的装箱（boxing）。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">性能改进承诺</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在我们的测试中，我们注意到有些领域取得了有趣的性能改进，而其他程序比没使用invoke 
dynamic支持的运行慢。然而，Groovy团队在Groovy 
2.1的pipeline中取得了进一步的性能改进，但我们注意到JVM还没有微调，全面优化仍然有很长的路要走。但所幸，即将到来的JDK 
7的更新（尤其是更新8）应该已经包含了这样的改进，这样的情况必将改善。此外，随着invoke dynamic被用于JDK 8的 
Lambdas实现，我们可以保证未来会有更大的改进。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">模块性更佳的Groovy</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">我们将通过模块化介绍，结束这次Groovy 
2.0新特性之旅。就像Java，Groovy不只是一门语言，它还是服务于多种用途的API集合：模板、Swing 
UI构建、Ant脚本、JMX集成、SQL访问、servlet服务等。Groovy的发布版就是把所有这些特性和API打成一个大的JAR。但不是所有人在自己的应用里总是需要所有内容：如果正在写Web应用，你会对模板引擎和Servlet感兴趣，但是如果正在做一个富桌面客户端程序，你可能仅需要Swing构建器。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy的模块</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">因此，本版本模块化的第一个目标就是将原始的Groovy 
JAR真真切切的划分成更小的模块、更小的JAR。核心的Groovy JAR文件现在缩小了一半，我们有如下可用的特性模块：</P>
<UL 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">
  <LI><B>Ant</B>：为自动化管理任务提供脚本化的Ant任务； 
  <LI><B>BSF</B>：用老的Apache 
  Bean脚本框架为你的Java应用集成Groovy； 
  <LI><B>Console</B>：包含Groovy Swing 
  console的模块； 
  <LI><B>GroovyDoc</B>：文档化你的Groovy和Java类； 
  <LI><B>Groovysh</B>：与Groovysh命令行shell相关的模块； 
  <LI><B>JMX</B>：暴露和消费JMX bean； 
  <LI><B>JSON</B>：生产和消费JSON 
  <LI><B>JSR-223</B>：使用JDK 6+ 
  javax.scripting API将Groovy集成到你的Java应用中 
  <LI><B>Servlet</B>：编写和服务Groovy 
  script servlet和template 
  <LI><B>SQL</B>：查询关系数据库； 
  <LI><B>Swing</B>：构建Swing UI； 
  <LI><B>Templates</B>：使用模板引擎 
  <LI><B>Test</B>：某些测试支持，如GroovyTestCase、mocking等等； 
  <LI><B>TestNG</B>：用Groovy写TestNG测试； 
  <LI><B>XML</B>：产生和消费XML文档。</LI></UL>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">对于Groovy 
2，你现在可以只挑选感兴趣的模块，而不用把所有内容都带入到classpath中。但我们仍提供包含所有内容的“完整”JAR，假如你不想只是为了节省一点空间就要处理复杂的依赖关系的话。我们还为运行在JDK7上的代码提供了用“invoke 
dynamic”支持选项编译后的JAR文件。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">扩展模块</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">让Groovy变得更模块化的工作也产生了一个有趣的新特性：扩展模块（extension 
module）。通过将Groovy分裂成更小模块，方便模块扩展方法的机制已经建立。由此，扩展模块可以给其他类，包括来自JDK或第三方库的类，提供实例和静态方法。Groovy用这种机制修饰了来自JDK的类，给诸如<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String、File</CODE>、流以及其他更多的类添加了新的有用方法 
- 例如，URL上的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">getText()</CODE>方法，允许你通过HTTP 
get获得远程URL的内容。还需要注意的是，静态类型检查器和编译器也知道你模块中的这些扩展方法。但先看看如何给现有类型添加新的方法。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">添加实例方法</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">要给现有类型添加新的方法，你必须创建一个包含这些方法的帮助类。在这个帮助类中，所有的扩展方法其实都是<CODE 
style="FONT: 12px/15px 'Courier New', Courier">public</CODE>的（这在Groovy中是缺省的，但若用Java实现，就需要标出）和<CODE 
style="FONT: 12px/15px 'Courier New', Courier">static</CODE>的（尽管它们将在类的实例中可用）。它们接受的第一个参数其实总是要在上面调用扩展方法的实例。余下参数将在调用时被传入。这跟Groovy的Category使用的是一样的惯例。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">假定我们要给<CODE 
style="FONT: 12px/15px 'Courier New', Courier">String</CODE>添加一个<CODE 
style="FONT: 12px/15px 'Courier New', Courier">greets()</CODE>方法， 
它向作为参数传入的人名问好，所以你可以像下面这样写：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>assert</B> "Guillaume".greets("Paul") == "Hi Paul, I'm Guillaume"</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">要实现它，你要创建一个含有这个扩展方法的帮助类，如：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>package</B> com.acme<BR><BR><B>class</B> MyExtension {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>static</B> String greets(String self, String name) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Hi ${name}, I'm ${self}"<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">添加静态方法</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">对于静态扩展方法，用同样的机制和惯例。现在我们给Random添加一个静态方法，获得两个值之间的一个随机整数，你可以按照这个类来处理：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>package</B> com.acme<BR><BR><B>class</B> MyStaticExtension {<BR>&nbsp;&nbsp;&nbsp;&nbsp;<B>static</B> String between(Random selfType, <B>int</B> start, <B>int</B> end) {<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>new</B> Random().nextInt(end - start + 1) + start<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>}</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">这样，你可以用如下方式使用这个扩展方法：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Random.between(3, 4)</PRE>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">扩展模块描述符</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">一旦编写好了包含扩展方法的帮助类（用Groovy或Java），你需要为模块创建描述符。你必须在模块文件夹的<CODE 
style="FONT: 12px/15px 'Courier New', Courier">META-INF/services</CODE>目录下创建一个名为<CODE 
style="FONT: 12px/15px 'Courier New', Courier">org.codehaus.groovy.runtime.ExtensionModule</CODE>的文件。可以定义四个基本属性，告诉Groovy运行时模块的名字和版本，以及用逗号隔开的类名列表，这些类就是为扩展方法写的帮助类。如下是我们最终的模块描述：</P><PRE style="OVERFLOW: auto; BORDER-TOP: rgb(239,239,239) 2px solid; BORDER-RIGHT: rgb(239,239,239) 2px solid; BORDER-BOTTOM: rgb(239,239,239) 2px solid; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(34,34,34); PADDING-BOTTOM: 5px; PADDING-TOP: 0px; FONT: 12px/15px 'Courier New', Courier; PADDING-LEFT: 0px; MARGIN: 0px; BORDER-LEFT: rgb(239,239,239) 2px solid; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; PADDING-RIGHT: 0px; WIDTH: 1003px; BACKGROUND-COLOR: rgb(250,250,250); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">moduleName = MyExtension<BR>moduleVersion = 1.0<BR>extensionClasses = com.acme.MyExtension<BR>staticExtensionClasses = com.acme.MyStaticExtension</PRE>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">一旦Classpath中有了这个扩展模块描述符，现在就能在代码中使用这些扩展方法了，不需要import或者其他动作，因为这些扩展方法是自动注册的。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">获取扩展</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">在脚本中使用@Grab注解可以从类似Maven 
Central这样的Maven库中获取依赖。此外，使用@GrabResolver注解，你还能为依赖指定自己的位置。如果你正通过这种机制“获取”一个扩展模块，扩展方法也会被自动安装。理想情况下，出于一致性考虑，模块名字和版本应该跟制品的id和版本关联。</P>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">总结</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy在Java开发人员中很流行，并为他们的应用提供了成熟的平台和生态系统。但我们并未满足于现状，Groovy开发团队会一如既往继续提高语言和它的API，帮助用户在Java平台上提高他们的生产率。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Groovy 
2.0致力于三个关键主题：</P>
<UL 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">
  <LI><B>更高性能</B>：借助<B>JDK 7 Invoke 
  Dynamic的支持</B>，它会为那些有幸在生产环境中已使用JDK7的开发者提高Groovy的速度；对于使用JDK 
  5及以上版本的所有人，则要借助<B>静态编译</B>，特别是那些打算放弃一些动态特性避免"猴子补丁"并想获得<B>与Java相同速度</B>的人而言。 
  <LI><B>对于Java更友好</B>：<B>Java 7 Project 
  Coin增强</B>的支持让Groovy和Java一如既往的表现为亲密的语法表兄弟，并且在<B>静态类型检查器</B>上给予将Groovy作为Java脚本语言的开发者跟javac编译器相同的反馈和类型安全。 
  <LI><B>模块化更佳</B>：借助新的模块化级别，Groovy开启了<B>更小交付包</B>的大门，例如，集成进Android上的<B>移动应用</B>，并允许Groovy 
  API发展和融入新的版本和新的扩展模块，同时还允许用户为现有类型贡献新的方法。</LI></UL>
<H2 
style="BACKGROUND-IMAGE: none; WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); PADDING-BOTTOM: 4px; PADDING-TOP: 4px; FONT: bold 19px arial; PADDING-LEFT: 0px; MARGIN: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: -1px; PADDING-RIGHT: 160px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">关于作者</H2>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><IMG 
style="BORDER-TOP: 0px; BORDER-RIGHT: 0px; BORDER-BOTTOM: 0px; BORDER-LEFT: 0px" 
hspace=3 alt="" align=left 
src="http://www.infoq.com/resource/articles/new-groovy-20/en/resources/glaforge.jpg" 
href="img://glaforge.jpg" _p="true" _>作为SpringSource的Groovy开发主管，VMware部门经理，<A 
style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://glaforge.appspot.com/" target=_blank>Guillaume 
Laforge</A>是官方的Groovy项目经理，领导Codehaus下的<A 
style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://groovy.codehaus.org/" target=_blank>Groovy</A>动态语言项目。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">他发起创建<A 
style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://grails.org/" target=_blank>Grails</A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>Web应用框架，建立了<A 
style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://gaelyk.appspot.com/" target=_blank>Gaelyk</A>项目，一个用Groovy为Google 
App 
Engine开发应用的轻量级的工具。他还是频繁在JavaOne、GR8Conf、SpringOne2GX、QCon和Devoxx等大会上介绍Groovy、Grails、Gaelyk、领域建模语言的会议发言人。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px">Guillaume也是法国French 
Java/OSS/IT播客<A style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://lescastcodeurs.com/" target=_blank>LesCastCodeurs</A>的创始成员之一。</P>
<P 
style="WHITE-SPACE: normal; TEXT-TRANSFORM: none; WORD-SPACING: 0px; COLOR: rgb(0,0,0); FONT: 13px/19px Lucida, 'Lucida Grande', Tahoma, sans-serif; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px"><B>原文链接：</B><A 
style="COLOR: rgb(11,89,178); TEXT-DECORATION: underline" 
href="http://www.infoq.com/articles/new-groovy-20">What’s new in Groovy 
2.0?</A></P></body>
</html>