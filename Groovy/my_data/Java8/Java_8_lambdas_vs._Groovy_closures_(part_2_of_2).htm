<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Java 8 lambdas vs. Groovy closures (part 2 of 2)</title>
<meta name="GENERATOR" content="WinCHM">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>
html,body { 
	/* Default Font */
	font-family: Arial, Helvetica, sans-serif;
	font-size: 11pt;
}
</style>

</head>

<body>
<DIV class="fauxcolumn-outer fauxcolumn-left-outer" 
style='OVERFLOW: hidden; FONT-SIZE: 14px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 0px; WHITE-SPACE: normal; WORD-SPACING: 0px; POSITION: absolute; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; LEFT: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TOP: 0px; BOTTOM: 0px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; font-variant-ligatures: normal; font-variant-caps: normal; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=fauxborder-left 
style="HEIGHT: 6284px; BACKGROUND-REPEAT: repeat-y; POSITION: relative; BACKGROUND-POSITION: left top"><BR 
class=Apple-interchange-newline>
<DIV class=fauxborder-right 
style="HEIGHT: 6284px; RIGHT: 0px; BACKGROUND-REPEAT: repeat-y; POSITION: absolute; BACKGROUND-POSITION: right top"></DIV>
<DIV class=fauxcolumn-inner 
style="HEIGHT: 6284px; BORDER-RIGHT: transparent 1px solid"></DIV></DIV>
<DIV class=cap-bottom 
style="HEIGHT: 0px; BACKGROUND-REPEAT: repeat-x; POSITION: relative; BACKGROUND-POSITION: left bottom">
<DIV class=cap-left 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: left bottom; FLOAT: left"></DIV>
<DIV class=cap-right 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: right bottom; FLOAT: right"></DIV></DIV></DIV>
<DIV class="fauxcolumn-outer fauxcolumn-right-outer" 
style='OVERFLOW: hidden; FONT-SIZE: 14px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WIDTH: 280px; WHITE-SPACE: normal; WORD-SPACING: 0px; RIGHT: 0px; POSITION: absolute; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TOP: 0px; BOTTOM: 0px; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; font-variant-ligatures: normal; font-variant-caps: normal; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=cap-top 
style="HEIGHT: 0px; BACKGROUND-REPEAT: repeat-x; POSITION: relative; BACKGROUND-POSITION: left top">
<DIV class=cap-left 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: left top; FLOAT: left"></DIV>
<DIV class=cap-right 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: right top; FLOAT: right"></DIV></DIV>
<DIV class=fauxborder-left 
style="HEIGHT: 6284px; BACKGROUND-REPEAT: repeat-y; POSITION: relative; BACKGROUND-POSITION: left top">
<DIV class=fauxborder-right 
style="HEIGHT: 6284px; RIGHT: 0px; BACKGROUND-REPEAT: repeat-y; POSITION: absolute; BACKGROUND-POSITION: right top"></DIV>
<DIV class=fauxcolumn-inner 
style="HEIGHT: 6284px; BORDER-LEFT: transparent 1px solid"></DIV></DIV>
<DIV class=cap-bottom 
style="HEIGHT: 0px; BACKGROUND-REPEAT: repeat-x; POSITION: relative; BACKGROUND-POSITION: left bottom">
<DIV class=cap-left 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: left bottom; FLOAT: left"></DIV>
<DIV class=cap-right 
style="HEIGHT: 0px; BACKGROUND-REPEAT: no-repeat; BACKGROUND-POSITION: right bottom; FLOAT: right"></DIV></DIV></DIV>
<DIV class=columns-inner 
style='FONT-SIZE: 14px; FONT-FAMILY: "Trebuchet MS", Trebuchet, Verdana, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(0,0,0); FONT-STYLE: normal; MIN-HEIGHT: 0px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; BACKGROUND-COLOR: rgb(255,255,255); TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px; font-variant-ligatures: normal; font-variant-caps: normal; text-decoration-style: initial; text-decoration-color: initial'>
<DIV class=column-center-outer 
style="WIDTH: 900px; POSITION: relative; FLOAT: left">
<DIV class=column-center-inner 
style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px">
<DIV id=main class="main section" style="MARGIN: 0px">
<DIV id=Blog1 class="widget Blog" 
style="POSITION: relative; MARGIN: 0px; MIN-HEIGHT: 0px; LINE-HEIGHT: 1.4" 
data-version="1">
<DIV class="blog-posts hfeed">
<DIV class=date-outer>
<H2 class=date-header 
style="POSITION: relative; FONT: bold 11px Arial, Tahoma, Helvetica, FreeSans, sans-serif; MARGIN: 0px; MIN-HEIGHT: 0px; font-stretch: normal"><SPAN 
style="COLOR: rgb(255,255,255); PADDING-BOTTOM: 0.4em; PADDING-TOP: 0.4em; PADDING-LEFT: 0.4em; LETTER-SPACING: 3px; PADDING-RIGHT: 0.4em; BACKGROUND-COLOR: rgb(187,187,187)">June 
7, 2015</SPAN></H2>
<DIV class=date-posts>
<DIV class=post-outer>
<DIV class="post hentry" 
style="POSITION: relative; MARGIN: 0px 0px 45px; MIN-HEIGHT: 0px" 
itemprop="blogPost" itemtype="http://schema.org/BlogPosting" 
itemscope="itemscope"><A name=1185779276876091973></A>
<H3 class="post-title entry-title" 
style='POSITION: relative; FONT: bold 30px "Trebuchet MS", Trebuchet, Verdana, sans-serif; MARGIN: 1.5em 0px 0.5em; font-stretch: normal' 
itemprop="name">Java 8 lambdas vs. Groovy closures (part 2 of 2)</H3>
<DIV class=post-header 
style="FONT-SIZE: 12px; MARGIN: 0px 0px 1.5em; LINE-HEIGHT: 1.6">
<DIV class=post-header-line-1><SPAN class=post-labels><A 
style="TEXT-DECORATION: none; BACKGROUND: rgb(238,238,238); COLOR: rgb(17,68,94); PADDING-BOTTOM: 0.4em; PADDING-TOP: 0.4em; PADDING-LEFT: 0.4em; PADDING-RIGHT: 0.4em" 
href="http://www.codebulb.ch/search/label/Groovy" 
rel=tag>Groovy</A><SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; BACKGROUND: rgb(238,238,238); COLOR: rgb(17,68,94); PADDING-BOTTOM: 0.4em; PADDING-TOP: 0.4em; PADDING-LEFT: 0.4em; PADDING-RIGHT: 0.4em" 
href="http://www.codebulb.ch/search/label/Java" 
rel=tag>Java</A></SPAN></DIV></DIV>
<DIV id=post-body-1185779276876091973 class="post-body entry-content" 
style="FONT-SIZE: 15px; WIDTH: 900px; POSITION: relative; MARGIN-TOP: -20px; LINE-HEIGHT: 1.4" 
itemprop="description articleBody"><BR><SPAN style="FONT-SIZE: large"><I>After 
taking a closer look at how Java 8 lambdas work and after some practical 
experience I have to conclude that Groovy’s closures are in every aspect, but 
most importantly from an “ease of development” point of view, superior to their 
Java 8 counterpart. Here comes part two of my in-depth 
assessment.<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-1.html">Please 
check out part 1 here first.</A></I></SPAN><SPAN>&nbsp;</SPAN><BR><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#collection" 
name=collection>
<H2 
style="CURSOR: default; FONT-SIZE: 23px; POSITION: relative; COLOR: black; MARGIN: 2em 0px 1em">Collection 
API</H2></A>Most prominently, predefined functions (closures / lambdas) are 
provided with the collection API which defines many ways to iterate over a 
collection.<BR>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Stream it, map it and 
collect it?</H3>As you may have already observed, Groovy closure calls for 
collections are in general much more concise than their lambda 
equivalent.<BR><BR>This is because in Groovy, closures are directly integrated 
in the actual Collection API: closures work on collections, and they return 
collections. You can thus operate on the actual collection without the need for 
any “builder pattern” approach to create intermediate objects. The single method 
call you need is a method named after the desired functionality.<BR><BR>For 
instance, this code line collects the result of upper casing each element in a 
list into a returning list:<BR><PRE class=brush:groovy>INPUT_LIST.collect {String myVar -&gt; myVar.toUpperCase()}</PRE>Below 
is the equivalent Java code. As you can see, one has to apply a complex builder 
sequence because lambdas cannot operate on collections directly and the actual 
computations are executed only in intermediate builder elements:<BR><PRE class=brush:java>INPUT_LIST.stream().map((String it) -&gt; it.toUpperCase()).collect(Collectors.toList());</PRE>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">With or without 
index</H3>The Java 8 streams API lacks the feature of getting the index of a 
stream element. Thus there is no Java equivalent to the following concise Groovy 
code:<BR><PRE class=brush:groovy>INPUT_LIST.eachWithIndex {it, i -&gt;
    OUTPUT_MAP[i.toString()] = it.toUpperCase()
}
return OUTPUT_MAP;</PRE>where<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">it</CODE><SPAN>&nbsp;</SPAN>is 
the current iteration element and<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">i</CODE><SPAN>&nbsp;</SPAN>is 
its index in the collection.<BR><BR>Please check out<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://stackoverflow.com/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8">this 
stackoverflow thread</A><SPAN>&nbsp;</SPAN>for (rather nasty) workarounds with 
Java lambdas.<BR>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Super-concisely 
collecting elements</H3>One of the most frequently used iterative functions is 
creating a new collection by applying a function on every object on a provided 
original collection; this is the “map” part of the famous map-reduce algorithm. 
It’s super easy the write it in plain Groovy:<BR><PRE class=brush:groovy>INPUT_LIST.collect {it.toUpperCase()}</PRE>In addition 
to that, Groovy provides an even more concise version known as the special 
“spread dot operator”. This line of code is equivalent:<BR><PRE class=brush:groovy>INPUT_LIST*.toUpperCase()</PRE>The spread dot operator 
applies a method not to the collection itself, but to every element of the 
collection, returning a new collection consisting of the method call return 
values.<BR><BR>With Java lambdas, there is no such thing. You have to stick with 
the one single version available for mapping:<BR><PRE class=brush:java>INPUT_LIST.stream().map(it -&gt; it.toUpperCase()).collect(Collectors.toList());</PRE>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Collecting 
maps</H3>Collect / map functionality which involve<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Map</CODE><SPAN>&nbsp;</SPAN>objects 
work quite different in Groovy and Java. As always, the Groovy version is 
typically more concise.<BR><BR>When collecting<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">List</CODE><SPAN>&nbsp;</SPAN>elements 
into a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Map</CODE>, 
the Groovy closure version returns a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">MapEntry</CODE><SPAN>&nbsp;</SPAN>with 
each function call:<BR><PRE class=brush:groovy>INPUT_LIST.collectEntries {[(it): it.toUpperCase()]}</PRE>whereas 
the Java lambda version uses a dedicated<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#toMap(…)</CODE><SPAN>&nbsp;</SPAN>Collector:<BR><PRE class=brush:java>INPUT_LIST.stream().collect(Collectors.toMap(it -&gt; it, it -&gt; it.toUpperCase()));</PRE>For 
the opposite case: when collecting<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Map</CODE><SPAN>&nbsp;</SPAN>elements 
into a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">List</CODE>, 
there’s a Groovy closure which takes two parameters, the first one is the key 
and the second one is the value:<BR><PRE class=brush:groovy>INPUT_MAP.collect { key, value -&gt; key + "=" + value }</PRE>This 
is very intuitive and straightforward. Another version which works with a 
single<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">MapEntry</CODE><SPAN>&nbsp;</SPAN>parameter 
is also available.<BR><BR>That latter version is however the only one available 
with Java lambdas:<BR><PRE class=brush:java>INPUT_MAP.entrySet().stream().map(it -&gt; it.getKey() + "=" + it.getValue()).collect(Collectors.toList());</PRE>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Easy finding / 
filtering</H3>Another very frequent operation is finding each element in a 
collection which matches a given predicate, which could also be perceived as 
“filtering” functionality.<BR><BR>Again, this is very straightforward in 
Groovy:<BR><PRE class=brush:groovy>INPUT_LIST.findAll {it == "c"} as List
INPUT_LIST.find {it == "c"}</PRE>Note that without<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">as 
List,</CODE><SPAN>&nbsp;</SPAN>the first line would return 
a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Collection</CODE><SPAN>&nbsp;</SPAN>object, 
not a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">List</CODE>, 
even if the original collection is in fact a List! The second version returns 
the one first matching object. Above code also uses the fact that in 
Groovy,<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">==</CODE><SPAN>&nbsp;</SPAN>is 
mapped to the<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#equals(…)</CODE><SPAN>&nbsp;</SPAN>method.<BR><BR>The 
Java version, on the other hand, is slightly more chatty:<BR><PRE class=brush:java>INPUT_LIST.stream().filter(it -&gt; it.equals("c")).collect(Collectors.toList());
INPUT_LIST.stream().filter(it -&gt; it.equals("c")).findFirst().get();</PRE>Note 
that the last line would return an<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Option&lt;T&gt;</CODE><SPAN>&nbsp;</SPAN>object 
if it weren’t for the<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#get()</CODE><SPAN>&nbsp;</SPAN>call.<BR>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Sorting and 
comparing</H3>Of course, both lambdas and closures support sorting and comparing 
collection elements whereas once again, the Groovy closure versions seem far 
more concise.<BR><BR>Here’s the Groovy version of sorting a List of Strings 
according to the first characters of each String in reverse order:<BR><PRE class=brush:groovy>INPUT_LIST.sort(false){(it as String).charAt(0)}.reverse(false)</PRE>The 
two boolean parameters with value<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">false</CODE><SPAN>&nbsp;</SPAN>will 
make sure sorting is executed on a copy of the list, not on the 
original.<BR><BR>At the moment,<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#sort(…)</CODE><SPAN>&nbsp;</SPAN>breaks 
type inference, thus it must be casted to String 
explicitly.<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="https://issues.apache.org/jira/browse/GROOVY-7061">This is a known 
bug.</A><BR><BR>Intriguingly, Java lambdas also have type inference problems 
when chaining comparators. For instance, the following line would not 
compile:<BR><PRE class=brush:java>INPUT_LIST.stream().sorted(Comparator.comparing(it -&gt; it.charAt(0)).reversed())
    .collect(Collectors.toList());</PRE>as<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">it</CODE><SPAN>&nbsp;</SPAN>cannot 
be inferred as being of type String.<BR><BR>For the rather simple reversing use 
case though, there luckily is an alternate syntax which works with 
inference:<BR><PRE class=brush:java>INPUT_LIST.stream().sorted(Comparator.comparing(it -&gt; it.charAt(0), Comparator.reverseOrder()))
    .collect(Collectors.toList());</PRE><BR>The details are discussed 
in<SPAN>&nbsp;</SPAN><A style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://stackoverflow.com/a/25192182/1399395">this stackoverflow 
thread</A>.<BR><BR>The same problem seems to apply when chaining comparators 
with<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#thenComparing(…)</CODE>, 
but this seems to be<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://stackoverflow.com/a/24442897/1399395">an error of the Eclipse 
compiler only</A>.<BR><BR>Let’s see another example: finding the max value based 
on a calculation done on each element of the collection. Here’s the Groovy 
solution:<BR><PRE class=brush:groovy>INPUT_LIST.max { it.charAt(0) }</PRE>And here’s the Java 
lambda counterpart:<BR><PRE class=brush:java>INPUT_LIST.stream().collect(Collectors.maxBy(Comparator.comparing(it -&gt; it.charAt(0)))).get();</PRE>Note 
that maxBy returns an<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Option&lt;T&gt;</CODE><SPAN>&nbsp;</SPAN>which 
you need to read through<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#get()</CODE>.<BR>
<H3 style="POSITION: relative; MARGIN: 1.5em 0px 0.5em">Other convenience 
functions</H3>Both Groovy and Java provide many auxiliary functions on 
collections which have been implemented with closures or lambdas, respectively. 
In general, though, the Groovy closure versions are more concise.<BR><BR>Here’s 
how to flatten a nested collection in Groovy:<BR><PRE class=brush:groovy>INPUT_LIST_NESTED.flatten()</PRE>And here’s the same 
instruction in Java:<BR><PRE class=brush:java>INPUT_LIST_NESTED.stream().flatMap(Collection::stream).collect(Collectors.toList());</PRE>Here’s 
how to join collection elements into a String with separator in Groovy:<BR><PRE class=brush:groovy>INPUT_LIST.join(", ")</PRE>And here’s the Java 
equivalent:<BR><PRE class=brush:java>INPUT_LIST.stream().collect(Collectors.joining(", "));</PRE>Note 
that in this latest example, the actual functionality happens in 
the<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#collect(…)</CODE><SPAN>&nbsp;</SPAN>“reducer” 
method.<SPAN>&nbsp;</SPAN><BR><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#numeric" 
name=numeric>
<H2 
style="CURSOR: default; FONT-SIZE: 23px; POSITION: relative; COLOR: black; MARGIN: 2em 0px 1em">Numeric 
/ Range API</H2></A>Another quite useful application for iteration and thus 
functional programming is dealing with numeric ranges.<BR><BR>Groovy actually 
provides a<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Range</CODE><SPAN>&nbsp;</SPAN>collection 
type which makes the syntax very smooth and natural:<BR><PRE class=brush:groovy>(RANGE_START..RANGE_END_INCLUSIVE).collect()</PRE>Java 
supports ranges as well, but their instantiation is clearly more cumbersome:<BR><PRE class=brush:java>IntStream.rangeClosed(RANGE_START, RANGE_END_INCLUSIVE).boxed().collect(Collectors.toList());</PRE><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#compiler" 
name=compiler>
<H2 
style="CURSOR: default; FONT-SIZE: 23px; POSITION: relative; COLOR: black; MARGIN: 2em 0px 1em">Compiler 
errors</H2></A>Finally, one last annoyance about Java 8 lambdas I will share 
here is the error reporting upon compile time error. These messages are 
typically just horrible, leaving the developer utterly confused.<BR><BR>For 
instance, what I did here was… wait, can you guess it from the compiler error 
message? Here’s the code:<BR><PRE class=brush:java>IntStream.rangeClosed(RANGE_START, RANGE_END_INCLUSIVE).collect(Collectors.toList());</PRE>And 
that’s the error:<SPAN>&nbsp;</SPAN><BR><PRE class="brush:text; class-name: error" style="COLOR: red">COMPILATION ERROR : 
-------------------------------------------------------------
projects/Java8LambdasVsGroovyClosures/src/main/java/ch/codebulb/java8lambdasvsgroovy/RangeTestsJava.java:[12,-1] 
1. ERROR in projects/Java8LambdasVsGroovyClosures/src/main/java/ch/codebulb/java8lambdasvsgroovy/RangeTestsJava.java (at line 12)
 return IntStream.rangeClosed(RANGE_START, RANGE_END_INCLUSIVE).collect(Collectors.toList());
                                                                ^^^^^^^
The method collect(Supplier&lt;R&gt;, ObjIntConsumer&lt;R&gt;, BiConsumer&lt;R,R&gt;) in the type IntStream is not applicable for the arguments 
    (Collector&lt;Object,capture#1-of ?,List&lt;Object&gt;&gt;)
----------

projects/Java8LambdasVsGroovyClosures/src/main/java/ch/codebulb/java8lambdasvsgroovy/RangeTestsJava.java:[12,-1] 
2. ERROR in projects/Java8LambdasVsGroovyClosures/src/main/java/ch/codebulb/java8lambdasvsgroovy/RangeTestsJava.java (at line 12)
 return IntStream.rangeClosed(RANGE_START, RANGE_END_INCLUSIVE).collect(Collectors.toList());
                                                                        ^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from Collector&lt;Object,?,List&lt;Object&gt;&gt; to Supplier&lt;R&gt;
----------
</PRE>I forgot to apply the<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#boxed()</CODE><SPAN>&nbsp;</SPAN>method 
on the range, which would unbox the<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Range</CODE><SPAN>&nbsp;</SPAN>of<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">Integer</CODE><SPAN>&nbsp;</SPAN>values 
to a range of<SPAN>&nbsp;</SPAN><CODE 
style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">int</CODE><SPAN>&nbsp;</SPAN>values.<BR><BR>This 
is pretty much a typical error message for any lambda compilation error (they’ll 
usually pop up in your IDE already rather than on the command line, but the 
problem stays the same). They typically include loads of references to nested 
generic types which of course is to be expected by the underlying generic 
abstraction layer of lambdas, but it’s making those error messages very hard to 
decipher nonetheless. I have to admit that in most cases the error message 
doesn’t help me at all in finding an error. I don’t care about how complex the 
underlying mechanisms of lambas are; I expect proper error reporting on the 
“lambda layer”, without inner classes and generic abstractions leaking 
through.<BR><BR>I have to admit that Groovy isn’t exactly well known for its 
excellent error reporting either, mostly due to its highly dynamic nature. 
Nonetheless, closure errors will in my experience typically either lead to quite 
readable error messages or Groovy will even run though anyways, with exception 
and stack trace at runtime (this is why dynamically typed programs are typically 
developed test-first).<SPAN>&nbsp;</SPAN><BR><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#conclusion" 
name=conclusion>
<H2 
style="CURSOR: default; FONT-SIZE: 23px; POSITION: relative; COLOR: black; MARGIN: 2em 0px 1em">Conclusion</H2></A>As 
I wrote in this article’s introduction, I have been looking forward to using the 
new exciting concept of lambdas in Java mostly because I really got into the 
apparently similar closure feature in Groovy, hoping to apply the same level of 
conciseness and readability to Java programs. Well, I was very 
wrong!<BR><BR>Both concepts share the same basic idea of promoting functional 
programming thus reducing side effects and facilitate parallel computing which I 
highly appreciate. And both languages doubtlessly do that very 
well.<BR><BR>However, there’s a huge difference in language design. Whilst in 
Groovy, writing iteration logic in closures is actually more readable thus 
increasing maintainability over e.g. use of nested for-loops, this is in my 
opinion not true for Java lambdas. Quite the contrary, lambdas are hard to write 
and quite hard to read with lots of boilerplate code which actually forces us to 
tradeoff the advantages of functional programming against the negative impact 
lambda coding style has on maintainability, and this is very bad.<BR><BR>There 
are some good ideas behind lambdas, but they don’t really matter at the end of 
the day when you just want to quickly implement some common iteration algorithm. 
In my opinion, both the grammar as well as the API need some serious 
revision.<BR><BR>When I do make use of lambdas in real world projects, I do so 
primarily for two use cases:<BR>
<UL 
style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2.5em; MARGIN: 0.5em 0px; LINE-HEIGHT: 1.4; PADDING-RIGHT: 2.5em">
  <LI 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 0.25em; PADDING-RIGHT: 0px; TEXT-INDENT: 0px">for 
  specific iteration algorithms such as<SPAN>&nbsp;</SPAN><CODE 
  style="FONT-SIZE: 13px; COLOR: rgb(20,82,112); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(241,248,251); border-radius: 4px">#find(…)</CODE><SPAN>&nbsp;</SPAN>which 
  can actually increase readability when compared with nested conditional 
  for-loops;</LI>
  <LI 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 0.25em; PADDING-RIGHT: 0px; TEXT-INDENT: 0px">and 
  to implement the<SPAN>&nbsp;</SPAN><I>command 
  pattern</I><SPAN>&nbsp;</SPAN>for runtime pluggable / interchangeable 
  behavior.</LI></UL>I originally intended to write this article for Groovy 
developers which are interested in the differences to lambdas and as a starting 
point to map their Groovy closure knowledge to the lambda world which I found 
quite hard myself. However, I do like to address Java developers as well to 
simply share my thoughts on the current state of lambdas. If you are a Java 
developer reading this far, I am keen on hearing whether you share some of my 
concerns. Feel free to comment below your experience and thoughts on working 
with Java 8 lambdas.<BR><BR>Again, you may also want to check out the 
accompanying GitHub project which contains all the code examples presented 
within the text, some additional lambda / closure examples and JUnit tests which 
prove equality of each lambda / closure implementation 
pair.<SPAN>&nbsp;</SPAN><BR><BR><B>Update September 6, 2015: Meanwhile, I’ve 
created<SPAN>&nbsp;</SPAN><I>LambdaOmega</I>, a small wrapper API for the Java 
Collection API which is more simple, concise and powerful than its vanilla Java 
counterpart. It especially fixes many flaws of the lambda API as discussed in 
this article.<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/08/lambdaomega-java-collections-lambdas-promises-simplified.html">Check 
out the accompanying blog post 
here</A><SPAN>&nbsp;</SPAN>or<SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="https://github.com/codebulb/LambdaOmega">visit its GitHub page</A>. 
Version 0.1 is now RELEASED!</B><BR><BR>
<DIV class=codebulb-reference-box>
<DIV><I class="fa fa-arrow-right" 
style="FONT-FAMILY: FontAwesome; FONT-WEIGHT: normal; FONT-STYLE: normal; DISPLAY: inline-block; LINE-HEIGHT: 1; -webkit-font-smoothing: antialiased"></I><B>You 
may also be interested in</B></DIV>
<DIV>
<UL 
style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 2.5em; MARGIN: 0.5em 0px; LINE-HEIGHT: 1.4; PADDING-RIGHT: 2.5em">
  <LI 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 0.25em; PADDING-RIGHT: 0px; TEXT-INDENT: 0px"><A 
  style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
  href="http://www.codebulb.ch/2015/06/painless-android-development-with-groovy-and-swissknife-part-1.html">Painless 
  Android development with Groovy and SwissKnife</A></LI>
  <LI 
  style="PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px 0px 0.25em; PADDING-RIGHT: 0px; TEXT-INDENT: 0px"><A 
  style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
  href="http://www.codebulb.ch/2015/03/10-most-useful-groovy-features-part-1.html">10 
  most useful Groovy features</A></LI></UL></DIV></DIV>
<P></P>
<DIV class=codebulb-postbox>
<DIV><A class=codebulb-button 
style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="https://github.com/codebulb/java8LambdasVsGroovyClosures" 
name=github-link><I class="fa fa-github fa-lg" 
style="FONT-SIZE: 1.33em; FONT-FAMILY: FontAwesome; VERTICAL-ALIGN: -15%; FONT-WEIGHT: normal; FONT-STYLE: normal; DISPLAY: inline-block; LINE-HEIGHT: 0.75em; -webkit-font-smoothing: antialiased"></I>View 
on GitHub</A></DIV>
<DIV><A style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/05/angularjs-mongodb-goodbye-middle-tier-part-1.html"><I></I><B>Previous 
post:</B><SPAN>&nbsp;</SPAN>AngularJS + MongoDB: Goodbye middle tier?</A></DIV>
<DIV><A style="TEXT-DECORATION: none; COLOR: rgb(17,68,94)" 
href="http://www.codebulb.ch/2015/06/clean-and-solid-java-ee-code-in-practice-part-1.html"><B>Next 
post:</B><SPAN>&nbsp;</SPAN>Clean and SOLID Java EE code in 
practice<I></I></A></DIV></DIV>
<P></P></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><BR 
class=Apple-interchange-newline></body>
</html>
