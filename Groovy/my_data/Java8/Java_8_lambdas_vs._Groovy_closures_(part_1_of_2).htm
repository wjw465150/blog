<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title></title>
  </head>
  <body>
    <div class="fauxcolumn-outer fauxcolumn-left-outer" style="position: absolute; top: 0px; bottom: 0px; overflow: hidden; left: 0px; width: 0px; color: rgb(0, 0, 0); font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;">
      <div class="fauxborder-left" style="background-position: left top; background-repeat: repeat-y; position: relative; height: 5649.44px;"><br
          class="Apple-interchange-newline">
        <div class="fauxborder-right" style="background-position: right top; background-repeat: repeat-y; position: absolute; right: 0px; height: 5649.44px;"></div>
        <div class="fauxcolumn-inner" style="height: 5649.44px; border-right: 1px solid transparent;"></div>
      </div>
      <div class="cap-bottom" style="position: relative; height: 0px; background-repeat: repeat-x; background-position: left bottom;">
        <div class="cap-left" style="height: 0px; background-repeat: no-repeat; background-position: left bottom; float: left;"></div>
        <div class="cap-right" style="height: 0px; background-repeat: no-repeat; background-position: right bottom; float: right;"></div>
      </div>
    </div>
    <div class="fauxcolumn-outer fauxcolumn-right-outer" style="position: absolute; top: 0px; bottom: 0px; overflow: hidden; right: 0px; width: 280px; color: rgb(0, 0, 0); font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;">
      <div class="cap-top" style="position: relative; height: 0px; background-repeat: repeat-x; background-position: left top;">
        <div class="cap-left" style="height: 0px; background-repeat: no-repeat; background-position: left top; float: left;"></div>
        <div class="cap-right" style="height: 0px; background-repeat: no-repeat; background-position: right top; float: right;"></div>
      </div>
      <div class="fauxborder-left" style="background-position: left top; background-repeat: repeat-y; position: relative; height: 5649.44px;">
        <div class="fauxborder-right" style="background-position: right top; background-repeat: repeat-y; position: absolute; right: 0px; height: 5649.44px;"></div>
        <div class="fauxcolumn-inner" style="height: 5649.44px; border-left: 1px solid transparent;"></div>
      </div>
      <div class="cap-bottom" style="position: relative; height: 0px; background-repeat: repeat-x; background-position: left bottom;">
        <div class="cap-left" style="height: 0px; background-repeat: no-repeat; background-position: left bottom; float: left;"></div>
        <div class="cap-right" style="height: 0px; background-repeat: no-repeat; background-position: right bottom; float: right;"></div>
      </div>
    </div>
    <div class="columns-inner" style="min-height: 0px; color: rgb(0, 0, 0); font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;">
      <div class="column-center-outer" style="position: relative; float: left; width: 900px;">
        <div class="column-center-inner" style="padding: 0px;">
          <div class="main section" id="main" style="margin: 0px;">
            <div class="widget Blog" data-version="1" id="Blog1" style="position: relative; min-height: 0px; margin: 0px; line-height: 1.4;">
              <div class="blog-posts hfeed">
                <div class="date-outer">
                  <div class="date-posts">
                    <div class="post-outer">
                      <div class="post hentry" itemprop="blogPost" itemscope="itemscope" itemtype="http://schema.org/BlogPosting"
                        style="position: relative; min-height: 0px; margin: 0px 0px 45px;"><br>
                        <h3 class="post-title entry-title" itemprop="name" style="margin: 1.5em 0px 0.5em; position: relative; font-style: normal; font-variant: normal; font-weight: bold; font-stretch: normal; font-size: 30px; line-height: normal; font-family: &quot;Trebuchet MS&quot;, Trebuchet, Verdana, sans-serif;">Java
                          8 lambdas vs. Groovy closures (part 1 of 2)</h3>
                        <div class="post-header" style="line-height: 1.6; margin: 0px 0px 1.5em; font-size: 12.6px;">
                          <div class="post-header-line-1"><span class="post-labels"><a href="http://www.codebulb.ch/search/label/Groovy"
                                rel="tag" style="text-decoration: none; color: rgb(17, 68, 94); background: rgb(238, 238, 238); padding: 0.4em;">Groovy</a><span>&nbsp;</span><a
                                href="http://www.codebulb.ch/search/label/Java" rel="tag" style="text-decoration: none; color: rgb(17, 68, 94); background: rgb(238, 238, 238); padding: 0.4em;">Java</a></span></div>
                        </div>
                        <div class="post-body entry-content" id="post-body-696369968035063902" itemprop="description articleBody"
                          style="width: 900px; font-size: 15.4px; line-height: 1.4; position: relative; margin-top: -20px;"><br>
                          <p></p>
                          <div class="codebulb-postbox">
                            <div><span class="codebulb-infobox codebulb-rating2">In-depth<i class="fa fa-lg" style="display: inline-block; font-family: FontAwesome; font-style: normal; font-weight: normal; line-height: 0.75em; -webkit-font-smoothing: antialiased; font-size: 1.33333em; vertical-align: -15%;"></i></span><span>&nbsp;</span><span
                                class="codebulb-infobox codebulb-rating3">Controversial<i class="fa fa-lg" style="display: inline-block; font-family: FontAwesome; font-style: normal; font-weight: normal; line-height: 0.75em; -webkit-font-smoothing: antialiased; font-size: 1.33333em; vertical-align: -15%;"></i></span><span>&nbsp;</span><a
                                href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#github-link"
                                class="codebulb-button" style="text-decoration: none; color: rgb(17, 68, 94);"><i class="fa fa-github fa-lg"
                                  style="display: inline-block; font-family: FontAwesome; font-style: normal; font-weight: normal; line-height: 0.75em; -webkit-font-smoothing: antialiased; font-size: 1.33333em; vertical-align: -15%;"></i>View
                                on GitHub</a></div>
                            <div><a href="http://www.codebulb.ch/2015/05/angularjs-mongodb-goodbye-middle-tier-part-1.html"
                                style="text-decoration: none; color: rgb(17, 68, 94);"><i></i><b>Previous post:</b><span>&nbsp;</span>AngularJS
                                + MongoDB: Goodbye middle tier?</a></div>
                            <div><a href="http://www.codebulb.ch/2015/06/clean-and-solid-java-ee-code-in-practice-part-1.html"
                                style="text-decoration: none; color: rgb(17, 68, 94);"><b>Next post:</b><span>&nbsp;</span>Clean
                                and SOLID Java EE code in practice<i></i></a></div>
                          </div>
                          <p></p>
                          <br>
                          <span style="font-size: large;"><i>As a Groovy enthusiast I was thrilled when Java 8 announced
                              to introduce the lamda feature for functional programming – as Groovy provides the
                              equivalent closure feature since its earliest releases. However, after taking a closer
                              look at how Java 8 lambdas work and after some practical experience I have to conclude
                              that Groovy’s closures are in every aspect, but most importantly from an “ease of
                              development” point of view, superior to their Java 8 counterpart. Here comes my in-depth
                              assessment.</i></span><span>&nbsp;</span><br>
                          <br>
                          <a href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-2.html#github-link"
                            style="text-decoration: none; color: rgb(17, 68, 94);"><b>View on GitHub:</b></a><span>&nbsp;</span>This
                          article is accompanied by a GitHub project which contains all the code examples presented
                          within the text, some additional lambda / closure examples and JUnit tests which prove
                          equality of each lambda / closure implementation pair. Feel free to check it out!<br>
                          <a href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-1.html#java" name="java"
                            style="text-decoration: none; color: rgb(17, 68, 94);">
                            <h2 style="margin: 2em 0px 1em; position: relative; font-size: 23.1px; cursor: default; color: black;">Java
                              lambdas vs. Groovy closures – some basics</h2>
                          </a>Groovy is a (optionally) dynamic and static typed language for the JVM which perfectly
                          integrates into Java – you can call Groovy code from within Java, and Java code from within
                          Groovy. Since its earliest releases, Groovy supports the so-called closures which since Java 8
                          now have their Java counterpart known as lambda expressions.<br>
                          <br>
                          However, there are some basic differences between lambdas and closures:<br>
                          <ul style="padding: 0px 2.5em; margin: 0.5em 0px; line-height: 1.4;">
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">A Java lambda really is
                              a functional interface which behaves like an anonymous inner class whereas Groovy closures
                              are instances of the<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">Closure</code><span>&nbsp;</span>class
                              which provides additional methods for inspection and dynamic behavior.</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">Both APIs are optimized
                              for parallel collection processing. For lambdas, you use the Collection API’s<span>&nbsp;</span><code
                                style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#parallelStream()</code><span>&nbsp;</span>method
                              instead of<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#stream()</code>;
                              in Groovy, concurrent implementations of iterator methods are provided by the<span>&nbsp;</span><a
                                href="http://www.gpars.org/guide/" style="text-decoration: none; color: rgb(17, 68, 94);">GPars</a><span>&nbsp;</span>extension.</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">Groovy’s syntax does not
                              support lambda expressions directly; however, you can put a (syntactically oftentimes more
                              concise) Groovy closure wherever an API expects a lambda expression.</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">Lambdas can only access
                              variables of the surrounding context if they are either explicitly or “effectively” final;
                              Groovy closures have access to any variables of the surrounding context.</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">Both languages support<span>&nbsp;</span><i>type
                                inference</i><span>&nbsp;</span>to reduce the need to explicitly declare parameter
                              types. When in “dynamic typing mode”, Groovy doesn’t evaluate any type information at
                              compile time at all.</li>
                          </ul>
                          <a href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-1.html#syntax"
                            name="syntax" style="text-decoration: none; color: rgb(17, 68, 94);">
                            <h2 style="margin: 2em 0px 1em; position: relative; font-size: 23.1px; cursor: default; color: black;">Syntax</h2>
                          </a>
                          <h3 style="margin: 1.5em 0px 0.5em; position: relative;">Parameters matter</h3>
                          First of all, Groovy adds the<span>&nbsp;</span><b>implicit parameter</b><span>&nbsp;</span><code
                            style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">it</code><span>&nbsp;</span>to
                          closures which operate on a single element, referring to that single element in the current
                          iteration:<br>
                          <pre class="brush:groovy">INPUT_LIST.collect {it.toUpperCase()}</pre>
                          In Java, there’s no such thing. You are forced to explicitly declare each parameter. The code
                          line closest to above Groovy code would thus be (I’ll address the otherwise bloated collection
                          API in a bit):<br>
                          <pre class="brush:java">INPUT_LIST.stream().map(it -&gt; it.toUpperCase()).collect(Collectors.toList());</pre>
                          Also, Groovy closures<span>&nbsp;</span><b>don’t force you to declare a single parameter</b><span>&nbsp;</span>if
                          you don’t need to refer to it at all.<br>
                          <br>
                          For instance, this Groovy code would return a list of “default” Strings, one for each element
                          in the collection (it’s a silly example for illustration purposes):<br>
                          <pre class="brush:groovy">INPUT_LIST.collect {"default"}</pre>
                          Whereas in Java, the equivalent would force you to still declare a parameter, e.g. for the<span>&nbsp;</span><code
                            style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#map(…)<span>&nbsp;</span></code>function,
                          even if you ignore it. The IDE will even complain about this.<br>
                          <pre class="brush:java">INPUT_LIST.stream().map(it -&gt; "default").collect(Collectors.toList());</pre>
                          Finally, having<span>&nbsp;</span><b>more than one parameter</b><span>&nbsp;</span>for lambda
                          expressions enforces a syntax change.<br>
                          <br>
                          While in Grovy, the syntax stays the same whether a lambda comes with one or more parameters,
                          e.g. in<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#inject(…)</code>:<br>
                          <pre class="brush:groovy">INPUT_LIST.inject("") { result, it -&gt; result + it }</pre>
                          in Java, you must remember to enclose lambda parameters in brackets if there’s more than one
                          of them:<br>
                          <pre class="brush:java">INPUT_LIST.stream().reduce("", ((result, it) -&gt; result + it));</pre>
                          c.f. the<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#map(…)</code><span>&nbsp;</span>method
                          where the single<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">it</code><span>&nbsp;</span>parameter
                          is not enclosed in brackets.<br>
                          <h3 style="margin: 1.5em 0px 0.5em; position: relative;">Bracket and semicolon hell</h3>
                          As we just saw, the number of parameters changes the syntax of Java lambdas. Unfortunately,
                          surprising syntactical changes do not stop there.<br>
                          <br>
                          Lambdas also apply a change in brackets rule when you give up<span>&nbsp;</span><b>type
                            inference</b><span>&nbsp;</span>in favor of explicitly declared types. Let’s compare these
                          two equivalent function calls in Groovy:<br>
                          <pre class="brush:groovy">INPUT_LIST.collect {String myVar -&gt; myVar.toUpperCase()}
INPUT_LIST.collect {myVar -&gt; myVar.toUpperCase()}</pre>
                          Although the first line uses explict typing, the syntax stays the same. Here’s the respective
                          Java code:<br>
                          <pre class="brush:java">INPUT_LIST.stream().map((String it) -&gt; it.toUpperCase()).collect(Collectors.toList());
INPUT_LIST.stream().map(it -&gt; it.toUpperCase()).collect(Collectors.toList());</pre>
                          Mind the extra brackets around the lambda parameter when explicit typing is used!<br>
                          <br>
                          As for semicolon use: In Groovy, statements do in general end with a newline rather than with
                          a semicolon which matches the syntax of many modern (JVM) languages. Therefore, it’s just
                          natural that the need to set semicolons in closures is already reduced when compared with Java
                          lambdas.<br>
                          <br>
                          Apart from the obvious semicolon changes, Java lambdas mess up pretty much the whole syntax as
                          soon as you use<span>&nbsp;</span><b>more than one statement</b><span>&nbsp;</span>in a lambda
                          expression.<br>
                          <br>
                          For instance, this Groovy code:<br>
                          <pre class="brush:groovy">INPUT_LIST.collect {String ret = it.toUpperCase(); ret}</pre>
                          uses the implict parameter<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">it</code><span>&nbsp;</span>and
                          the closure body consists of two statements, separated by semicolon. The syntax is clear,
                          concise and in accord with previous examples. (Although the example code as such is silly, of
                          course.)<br>
                          <br>
                          However, in the lambda equivalent, lots of changes are enforced just by the presence of
                          another expression in the lambda body:<br>
                          <pre class="brush:java">INPUT_LIST.stream().map(it -&gt; {String ret = it.toUpperCase(); return ret;}).collect(Collectors.toList());</pre>
                          <ul style="padding: 0px 2.5em; margin: 0.5em 0px; line-height: 1.4;">
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">the body must be
                              enclosed in angle brackets</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">every statement,
                              including the last one, must end with a semicolon</li>
                            <li style="padding: 0px; margin: 0px 0px 0.25em; text-indent: 0px;">the last statement must
                              be an explicit<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">return</code><span>&nbsp;</span>statement</li>
                          </ul>
                          <h3 style="margin: 1.5em 0px 0.5em; position: relative;">Go dynamic if you want to</h3>
                          Note that although Groovy can optionally be dynamic typed locally at your discretion, all the
                          code samples in this article work with dynamic typing as well as with static typing.<br>
                          <br>
                          However, in some situations, it might be useful to take advantage of dynamic typing to reduce
                          the need for boilerplate code. It turns out that this is especially true for collection
                          iterations as covered by closures / lambdas.<br>
                          <br>
                          To illustrate this, I will here repeat an example I created for<span>&nbsp;</span><a href="http://www.codebulb.ch/2015/03/10-most-useful-groovy-features-part-1.html"
                            style="text-decoration: none; color: rgb(17, 68, 94);">a previous blog post about some of
                            Groovy’s top features:</a><br>
                          <br>
                          In Groovy:<br>
                          <pre class="brush:groovy">private static final List&lt;?&gt; INVENTORY = [
    new Car(), new Car(),
    new TV(), new TV(), new TV()
]

private static class Car {
    public final int cost = 10000
}

private static class TV {
    public final int cost = 1000
}

@CompileDynamic
public static int sumDynamic() {
    return INVENTORY.sum { it.cost } as int
}
</pre>In Java:<br>
                          <pre class="brush:java">private static final List&lt;?&gt; INVENTORY = new ArrayList&lt;&gt;(Arrays.asList(
    new Car(), new Car(),
    new TV(), new TV(), new TV()
));

private static class Car {
    public final int cost = 10000;
}

private static class TV {
    public final int cost = 1000;
}

public static int sumDynamic() {        
    return INVENTORY.stream().mapToInt(it -&gt; {
        if (it instanceof Car) {
            return ((Car)it).cost;
        }
        else if (it instanceof TV) {
            return ((TV)it).cost;
        }
        else {
            throw new IllegalArgumentException("Unexpected type: " + it);
        }
    }).sum();
}
</pre>In Java, you are forced to check and cast an object even if you know that a given method is present; in Groovy,
                          due to its dynamic type system known as “duck typing”, you are free to call any method on any
                          object.<br>
                          <br>
                          I still think it’s an architectural impediment to have the dynamic vs. static choice taken
                          away globally by the programming language’s design.<br>
                          <br>
                          <h3 style="margin: 1.5em 0px 0.5em; position: relative;">…plus all the other Groovy features</h3>
                          Let’s not forget that when programming in Groovy, you also have a vast number of additional
                          features and syntactic enhancements at hand which can dramatically increase ease of
                          development, many of which are particularly useful when working with iterations and
                          collections, most notably<span>&nbsp;</span><b>collection literals</b>,<span>&nbsp;</span><b>String
                            interpolation</b><span>&nbsp;</span>and<span>&nbsp;</span><b>JavaBean properties</b>.<br>
                          <br>
                          And, if you really need to, Groovy also gives you the tools to modify existing types, e.g. add
                          additional collection methods, which matches the closure / lambda functional programming style
                          much better than implementing additional features in static helper methods.<br>
                          <a href="http://www.codebulb.ch/2015/06/java-8-lambdas-vs-groovy-closures-part-1.html#defining"
                            name="defining" style="text-decoration: none; color: rgb(17, 68, 94);">
                            <h2 style="margin: 2em 0px 1em; position: relative; font-size: 23.1px; cursor: default; color: black;">Defining
                              a function</h2>
                          </a>Due to the different underlying mechanisms of Groovy closures and Java lambdas, defining
                          your own function works quite different in those two languages.<br>
                          <br>
                          For Groovy, you always build a (return value-typed)<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">Closure</code><span>&nbsp;</span>which
                          can be executed with<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">#call(…)</code><span>&nbsp;</span>or
                          by simply putting the arguments in brackets, just as a method call. Here’s an example of
                          defining, referencing and using a custom Groovy closure:<br>
                          <pre class="brush:groovy">public static int calculateWithFunction() {
    Closure&lt;Integer&gt; function = {int x -&gt; x*2};
    return useFunction(function, INPUT_VALUE);
}

private static int useFunction(Closure&lt;Integer&gt; function, int inputValue) {
    return function(inputValue);
}
</pre>Unfortunately, I didn’t find any official information about the maximum supported arity (number of parameters) of
                          a closure, but I’ve empirically tested it with 7, and any more than that would result in
                          unreadable code anyways.<br>
                          <br>
                          Now in Java, there are actually<span>&nbsp;</span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html"
                            style="text-decoration: none; color: rgb(17, 68, 94);">43 interfaces</a><span>&nbsp;</span>you
                          can or rather must choose from in order to implement a lambda function, each one representing
                          a specific case out of a variety of functional interface use cases such as very generic
                          functions, functions for each primitive type, functions distinguished by their arity,
                          functions with or without return value. This might sound like a quite flexible solution, but I
                          don’t agree with that; rather, I’d like to cite here from the<span>&nbsp;</span><a href="http://java.dzone.com/articles/whats-wrong-java-8-part-ii"
                            style="text-decoration: none; color: rgb(17, 68, 94);">What's Wrong in Java 8</a><span>&nbsp;</span>article
                          (which is a fun read as well):<br>
                          <i><br>
                          </i><i>“What a mess! And furthermore, the methods of these interfaces have different names.
                            Object functions have a method named apply, where methods returning numeric primitives have
                            method name applyAsInt, applyAsLong, or applyAsDouble. Functions returning boolean have a
                            method called test, and suppliers have methods called get, or getAsInt, getAsLong,
                            getAsDouble, or getAsBoolean. (They did not dare calling BooleanSupplier “Predicate” with a
                            test method taking no argument. I really wonder why!)</i><br>
                          <i>One thing to note is that there are no functions for byte, char, short and float. Nor are
                            there functions for arity greater that two. Needless to say, this is totally ridiculous.”</i><br>
                          <br>
                          For this example, I implemented the very generic<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">Function</code><span>&nbsp;</span>interface:<br>
                          <pre class="brush:java">public static int calculateWithFunction() {
    Function&lt;Integer, Integer&gt; function = x -&gt; x*2;
    return useFunction(function, INPUT_VALUE);
}

private static int useFunction(Function&lt;Integer, Integer&gt; function, int inputValue) {
    return function.apply(inputValue);
}
</pre>Note that if I would explicitly specify the function’s parameter’s type as<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">int</code><span>&nbsp;</span>instead
                          of<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">Integer</code>,
                          it wouldn’t compile as Autoboxing doesn’t work with functions due to the underlying generics
                          mechanisms. I would have to resort to the less generic<span>&nbsp;</span><code style="background-color: rgb(241, 248, 251); border-radius: 4px; color: rgb(20, 82, 112); font-size: 13.86px; padding: 2px 4px;">IntFunction</code><span>&nbsp;</span>interface.<br>
                          <h3 style="margin: 1.5em 0px 0.5em; position: relative;">Method references</h3>
                          Both languages also support referencing methods as functions (lambdas or closures,
                          respectively). Referencing a function as such works really similar in Java and Groovy, only
                          the operator is different.<br>
                          <br>
                          Here’s the Groovy solution:<br>
                          <pre class="brush:groovy">Closure&lt;Character&gt; function = INPUT_STRING.&amp;charAt;
return function(0) as char;</pre>
                          And here’s the Java solution:<br>
                          <pre class="brush:java">Function&lt;Integer, Character&gt; function = INPUT_STRING::charAt;
return function.apply(0);</pre>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
