<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Gradle的依赖管理(Repository&Dependency )</title>
<meta name="GENERATOR" content="WinCHM">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>
html,body { 
	/* Default Font */
	font-family: Arial, Helvetica, sans-serif;
	font-size: 11pt;
}
</style>

</head>

<body>
<DIV class=titlepage 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV>
<DIV>
<H1 xmlns:xslthl="http://xslthl.sf.net">Chapter&nbsp;44.&nbsp;Dependency 
Management</H1></DIV></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=sec_Introduction></A>44.1.&nbsp;Introduction</H2></DIV></DIV></DIV>
<P>Gradle offers a very good support for dependency management. If you are 
familiar with Maven or Ivy approach you will be delighted to learn that:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>Gradle fully supports transitive dependency management. Gradle also 
  works<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
  class=emphasis><EM>perfectly</EM></SPAN><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>with your existent dependency 
  management infrastructure, be it Maven or Ivy. All the repositories you have 
  set up with your custom POM or ivy files can be used as they are. No changes 
  necessary.</P></LI>
  <LI class=listitem>
  <P>If you don't use transitive dependency management and your external 
  libraries live just as files in version control or on some shared drive, 
  Gradle provides powerful functionality to support this.</P></LI>
  <LI class=listitem>
  <P>Gradle provides an additional, optional support for transitive dependency 
  management that is not based on XML descriptor files called Module 
  Dependencies, where you describe the dependency hierarchy in the build 
  script.</P></LI>
  <LI class=listitem>
  <P>The job of a build system is to support all major patterns for how people 
  deal with dependencies, not to force people in a certain way of doing things. 
  In particular for migration scenarios it is extremely important that any 
  current approach is supported so that you can use the same input structure in 
  the new evolving Gradle build than in the existing build as long as it is in 
  production. That enables you to compare the results. Gradle is extremely 
  flexible. So even if your project is using a custom dependency management or 
  say an Eclipse .classpath file as master data for dependency management, it 
  would be very easy to write a little adaptor plugin to use this data in 
  Gradle. For migration purposes this is a common technique with Gradle. Once 
  you have migrated, it might be a good idea though not to use a .classpath file 
  for dependency metadata any longer :).</P></LI></UL></DIV>
<P></P></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=sec_dependency_management_overview></A>44.2.&nbsp;Dependency Management 
Best Practices.</H2></DIV></DIV></DIV>
<P>We have an opinion on what are dependency management best practices. As 
usual, Gradle does not force our opinion onto you, but supports any kind of 
pattern you want to use. Nonetheless we would like to share our opinion.</P>
<P>We think good dependency management is very important for almost any project. 
Yet the kind of dependency management you need depends on the complexity and the 
environment of your project. Is your project a distribution or a library? Is it 
part of an enterprise environment, where it is integrated into other projects 
builds or not? But all types of projects should follow the rules below:</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:versioning_the_jar_name></A>44.2.1.&nbsp;Versioning 
the jar name</H3></DIV></DIV></DIV>
<P>The version of the jar must be easy to recognize. Sometimes the version is in 
the Manifest file of the jar, often not. And even if, it is rather painful to 
always look into the Manifest file to learn about the version. Therefore we 
think that you should only use jars which have their version as part of their 
file name. If you are using transitive dependency management you are forced to 
do this in any case.</P>
<P>Why do we think this is important? Without a dependency management as 
described above, your are likely to burn your fingers sooner or later. If it is 
unclear which version of a jar your are using, this can introduce subtle bugs 
which are very hard to find. For example there might be a project which uses 
Hibernate 3.0.4. There are some problems with Hibernate so a developer installs 
version 3.0.5 of Hibernate on her machine. This did not solve the problem but 
she forgot to roll back Hibernate to 3.0.4. Weeks later there is an exception on 
the integration machine which can't be reproduced on the developer machine. 
Without a version in the jar name this problem might take a long time to debug. 
Version in the jar names increases the expressiveness of your project and makes 
it easier to maintain.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sub:transitive_dependency_management></A>44.2.2.&nbsp;Use some form of 
transitive dependency management</H3></DIV></DIV></DIV>
<P>When we talk about transitive dependency management, we mean any technique 
that enables to distinguish between what are the first level dependencies and 
what are the transitive ones. We will about different techniques for this later 
on.</P>
<P>Why is transitive dependency management so important? If you don't know which 
dependencies are first level dependencies and which ones are transitive you will 
soon lose control over your build. Even a non enterprise project Gradle has 
already 100+ jars. An enterprise project using Spring, Hibernate, etc. easily 
ends up with many more jars. There is no way to memorize where all these jars 
come from. If you want to get rid of a first level dependency you can't be sure 
which other jars you should remove. Because a dependency of a first level 
dependency might also be a first level dependency itself. Or it might be a 
transitive dependency of another of your first level dependencies. Many first 
level dependencies are runtime dependencies and the transitive dependencies are 
of course all runtime dependencies. So the compiler won't help you much here. 
The end of the story is, as we have seen very often, no one dares to remove any 
jar any longer. The project classpath is a complete mess and if a classpath 
problem arises, hell on earth invites you for a ride. In one of our former 
projects, we found some ldap related jar in the classpath, whose sheer presence, 
as we found out after much research, accelerated LDAP access. So removing this 
jar would not have led to any errors at compile or runtime.</P>
<P>Gradle offers you different ways to express what are first level and what are 
transitive dependencies. Gradle allows you for example to store your jars in CVS 
or SVN without XML descriptor files and still use transitive dependency 
management. Also, not all techniques for transitive dependency management deal 
with the problem described above equally well.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:version_conflicts></A>44.2.3.&nbsp;Version 
conflicts</H3></DIV></DIV></DIV>
<P>Conflicting versions of the same jar should be detected and either resolved 
or cause an exception. If you don't use transitive dependency management, 
version conflicts are undetected and the mostly accidental fragile order of the 
classpath will determine, what version of a dependency will win. For example 
adding a dependency with a particular version to a subproject might change that 
order and then will led to all kind of surprising side effects. You might also 
want to learn where conflicting versions are used as you might want to 
consolidate on a particular version of an dependency across your organization. 
With a good conflict reporting that information can be used to communicate with 
the teams to solve this.</P>
<P>It is common that different dependencies rely on different versions of 
another dependency which leads to a version conflictm as The JVM unfortunately 
does not offer yet any easy way, to have different versions of the same jar in 
the classpath (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="dependency_management.html#sub:dependency_management_and_java">Section&nbsp;44.2.5, 
“Dependency management and Java”</A>).</P>
<P>Gradle offers following conflict resolution strategies:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem><SPAN class=emphasis><EM>Newest</EM></SPAN><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>- used by default by Gradle - the 
  newest version of the dependency is used. This strategy has been in Gradle 
  since early days.</LI>
  <LI class=listitem><SPAN class=emphasis><EM>Fail</EM></SPAN><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>- fail eagerly on version conflict. 
  Useful if you need extra control and manage the conflicts manually. Introduced 
  in<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=code>1.0-milestone-6</CODE>. See<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
  href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" 
  target=_top><CODE class=classname>ResolutionStrategy</CODE></A><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>for reference on managing the 
  conflict resolution strategies.</LI>
  <LI class=listitem>We are working on making conflict resolution fully 
  customizable.</LI></UL></DIV>
<P>Gradle provides means to resolve version conflicts:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>Configuring a first level dependency as<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN 
  class=emphasis><EM>forced</EM></SPAN>. The feature has been in Gradle since 
  early days. This approach is useful if the dependency incurring conflict is 
  already a first level dependency. See examples in<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
  href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" 
  target=_top><CODE class=classname>DependencyHandler</CODE></A></LI>
  <LI class=listitem>Configuring any dependency (transitive or not) as<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN 
  class=emphasis><EM>forced</EM></SPAN>. The feature was introduced in<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=code>1.0-milestone-7</CODE>. This approach is useful if the dependency 
  incurring conflict is a transitive dependency. It also can be used to force 
  versions of first level dependencies. See examples in<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
  href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" 
  target=_top><CODE class=classname>ResolutionStrategy</CODE></A></LI></UL></DIV>
<P>To deal with problems due to version conflicts, reports with dependency 
graphs are also very helpful. Such reports are another feature of dependency 
management.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sub:dynamic_versions_and_changing_modules></A>44.2.4.&nbsp;Dynamic Versions 
and Changing Modules</H3></DIV></DIV></DIV>
<P>Sometimes, you always want to use the latest version of a particular 
dependency, or the latest in a range of versions. You can easily do this using 
a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>dynamic 
version</EM></SPAN>. A dynamic version can be either a version range (eg.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>2.+</CODE>) or it 
can be a placeholder for the latest version available (eg.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>latest.integration</CODE>).</P>
<P>Alternatively, sometimes the module you request can change over time, even 
for the same version. An example of this type of<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>changing 
module</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is a maven<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>SNAPSHOT</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>module, which always points at the 
latest artifacts published.</P>
<P>The main difference between a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>dynamic 
version</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>changing 
module</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>is that when 
you resolve a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>dynamic version</EM></SPAN>, you'll get the real, static 
version as the module name. When you resolve a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>changing 
module</EM></SPAN>, the artifacts are named using the version you requested, but 
the underlying artifacts may change over time.</P>
<P>By default, Gradle caches dynamic versions and changing modules for 24 hours. 
You can override the default cache modes using<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=link 
href="dependency_management.html#sec_cache_command_line_options">command line 
options</A>. You can change the cache expiry times in your build using the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>resolution 
strategy</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>(see<A class=xref 
href="dependency_management.html#sec_controlling_caching">Section&nbsp;44.8.3, 
“Fine-tuned control over dependency caching”</A>).</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sub:dependency_management_and_java></A>44.2.5.&nbsp;Dependency management 
and Java</H3></DIV></DIV></DIV>
<P>Traditionally, Java has offered no support at all for dealing with libraries 
and versions. There are no standard ways to say that<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>foo-1.0.jar</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>depends on a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>bar-2.0.jar</CODE>. 
This has led to proprietary solutions. The most popular ones are Maven and Ivy. 
Maven is a complete build system whereas Ivy focuses solely on dependency 
management.</P>
<P>Both approaches rely on descriptor XML files, which contains information 
about the dependencies of a particular jar. Both also use repositories where the 
actual jars are placed together with their descriptor files. And both offer 
resolution for conflicting jar versions in one form or the other. Yet we think 
the differences of both approaches are significant in terms of flexibility and 
maintainability. Originally Gradle did use Ivy under the hood for its dependency 
management. This has been replaced with a native Gradle dependency resolution 
engine. This resolution engine supports both pom and ivy descriptor 
files.</P></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=sub:configurations></A>44.3.&nbsp;Dependency 
configurations</H2></DIV></DIV></DIV>
<P>In Gradle dependencies are grouped into configurations. Configurations have a 
name, a number of other properties, and they can extend each other. Many Gradle 
plugin add pre-defined configurations to your project. The Java plugin, for 
example, adds some configurations to represent the various classpaths it needs. 
see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="java_plugin.html#sec_java_plugin_and_dependency_management">Section&nbsp;23.5, 
“Dependency management”</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>for 
details. Of course you can add your add custom configurations on top of that. 
There are many use cases for custom configurations. This is very handy for 
example for adding dependencies not needed for building or testing your software 
(e.g. additional JDBC drivers to be shipped with your distribution).</P>
<P>A project's configurations are managed by a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>configurations</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>object. The closure you pass to the 
configurations object is applied against its API. To learn more about this API 
have a look at<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" 
target=_top><CODE class=classname>ConfigurationContainer</CODE></A>.</P>
<P>To define a configuration:</P>
<DIV class=example><A name=defineConfiguration></A>
<P class=title><B>Example&nbsp;44.1.&nbsp;Definition of a configuration</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations {
    compile
}</PRE></DIV></DIV><BR class=example-break>
<P>To access a configuration:</P>
<DIV class=example><A name=defineConfiguration></A>
<P class=title><B>Example&nbsp;44.2.&nbsp;Accessing a configuration</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>println configurations.compile.name
println configurations[<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'compile'</SPAN>].name</PRE></DIV></DIV><BR 
class=example-break>
<P>To configure a configuration:</P>
<DIV class=example><A name=defineConfiguration></A>
<P class=title><B>Example&nbsp;44.3.&nbsp;Configuration of a 
configuration</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations {
    compile {
        description = <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'compile classpath'</SPAN>
        transitive = true
    }
    runtime {
        extendsFrom compile
    }
}
configurations.compile {
    description = <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'compile classpath'</SPAN>
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=sec_how_to_declare_your_dependencies></A>44.4.&nbsp;How 
to declare your dependencies</H2></DIV></DIV></DIV>
<P>There are several different types of dependencies that you can declare:</P>
<DIV class=table xmlns:xslthl="http://xslthl.sf.net">
<P class=title><B>Table&nbsp;44.1.&nbsp;Dependency types</B></P>
<DIV class=table-contents>
<TABLE id=N13FAA>
  <THEAD>
  <TR>
    <TD>Type</TD>
    <TD>Description</TD></TR></THEAD>
  
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:module_dependencies">External module 
      dependency</A></TD>
    <TD>A dependency on an external module in some repository.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:project_dependencies">Project 
      dependency</A></TD>
    <TD>A dependency on another project in the same build.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:file_dependencies">File 
    dependency</A></TD>
    <TD>A dependency on a set of files on the local filesystem.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:client_module_dependencies">Client 
      module dependency</A></TD>
    <TD>A dependency on an external module, where the artifacts are located in 
      some repository but the module meta-data is specified by the local build. 
      You use this kind of dependency when you want to override the meta-data 
      for the module.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:api_dependencies">Gradle API 
      dependency</A></TD>
    <TD>A dependency on the API of the current Gradle version. You use this 
      kind of dependency when you are developing custom Gradle plugins and task 
      types.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:groovy_dependencies">Local Groovy 
      dependency</A></TD>
    <TD>A dependency on the Groovy version used by the current Gradle version. 
      You use this kind of dependency when you are developing custom Gradle 
      plugins and task types.</TD></TR></TABLE></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:module_dependencies></A>44.4.1.&nbsp;External module 
dependencies</H3></DIV></DIV></DIV>
<P>External module dependencies are the most common dependencies. They refer to 
a module in an external repository.</P>
<DIV class=example><A name=moduleDependencies></A>
<P class=title><B>Example&nbsp;44.4.&nbsp;Module dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.springframework'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'spring-core'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'2.5'</SPAN>
    runtime <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.springframework:spring-core:2.5'</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.springframework:spring-aop:2.5'</SPAN>
    runtime(
        [group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.springframework'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'spring-core'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'2.5'</SPAN>],
        [group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.springframework'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'spring-aop'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'2.5'</SPAN>]
    )
    runtime(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.hibernate:hibernate:3.0.5'</SPAN>) {
        transitive = true
    }
    runtime group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.hibernate'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'hibernate'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'3.0.5'</SPAN>, transitive: true
    runtime(group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.hibernate'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'hibernate'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'3.0.5'</SPAN>) {
        transitive = true
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>Please see the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" 
target=_top><CODE class=classname>DependencyHandler</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>for more examples and complete 
reference. Please read on to get thorough understanding of the Gradle's 
dependency management.</P>
<P>Gradle provides different notations for module dependencies. There is a 
string notation and a map notation. A module dependency has an API which allows 
for further configuration. Have a look at<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" 
target=_top><CODE class=classname>ExternalModuleDependency</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>to learn all about the API. This API 
provides properties and configuration methods. Via the string notation you can 
define a subset the properties. With the map notation you can define all 
properties. To have access to the complete API, either with the map or with the 
string notation, you can assign a single dependency to a configuration together 
with a closure.</P>
<P>If you declare a module dependency, Gradle looks for a corresponding module 
descriptor file (<CODE class=literal>pom.xml</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>or<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>ivy.xml</CODE>) in 
the repositories. If such a module descriptor file exists, it is parsed and the 
artifacts of this module (e.g.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>hibernate-3.0.5.jar</CODE>) as well as its dependencies (e.g. 
cglib) are downloaded. If no such module descriptor file exists, Gradle looks 
for a file called<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>hibernate-3.0.5.jar</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>to retrieve. In Maven a module can only 
have one and only one artifact. In Gradle and Ivy a module can have multiple 
artifacts. Each artifact can have a different set of dependencies.</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=ssub:multi_artifact_dependencies></A>44.4.1.1.&nbsp;Depending on modules 
with multiple artifacts</H4></DIV></DIV></DIV>As mentioned earlier, a maven 
module has only one artifact. So, when your project depends on a maven module 
it's obvious what artifact is the actual dependency. With Gradle or Ivy the case 
is different. Ivy model of dependencies (<CODE class=literal>ivy.xml</CODE>) can 
declare multiple artifacts. For more information, see Ivy reference for<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>ivy.xml</CODE>. In 
Gradle, when you declare a dependency on an ivy module you actually declare 
dependency on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>'default'</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>configuration of that module. So the 
actual list of artifacts (typically jars) your project depends on, are all 
artifacts that are attached to the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>default</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>configuration of that module. This is 
very important in following exemplary use cases:
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>default</CODE><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>configuration of some module contains 
  some artifacts you don't want on the classpath. You might need to configure a 
  dependency on specific artifact(s) of given module, rather than pulling all 
  artifacts of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>default</CODE>dependency</LI>
  <LI class=listitem>The artifact you need on the classpath has been published 
  in a different configuration than the<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>default</CODE><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>one. This means this artifact will 
  not be pulled in by Gradle. Unless you explicitly declare what configuration 
  of the module you depend on.</LI></UL></DIV>There are other situations where it 
is necessary to fine-tune the dependency declaration. Please see the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" 
target=_top><CODE class=classname>DependencyHandler</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>for examples and complete reference on 
declaring dependencies.</DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=ssub:artifact_dependencies></A>44.4.1.2.&nbsp;Artifact 
only notation</H4></DIV></DIV></DIV>
<P>As said above, if no module descriptor file can be found, Gradle by default 
downloads a jar with the name of the module. But sometimes, even if the 
repository contains module descriptors, you want to download only the artifact 
jar, without the dependencies.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SUP>[<A class=footnote 
href="#ftn.N14049" name=N14049>12</A>]</SUP><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>And sometimes you want to download a 
zip from a repository, that does not have module descriptors. Gradle provides 
an<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>artifact only</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>notation for those use cases - simply 
prefix the extension that you want to be downloaded with<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>'@'</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>sign:</P>
<DIV class=example><A name=artifactOnly></A>
<P class=title><B>Example&nbsp;44.5.&nbsp;Artifact only notation</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.groovy:groovy:1.8.8@jar"</SPAN>
    runtime group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.groovy'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'groovy'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'1.8.8'</SPAN>, ext: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'jar'</SPAN>
}</PRE></DIV></DIV>
<P><BR class=example-break>An artifact only notation creates a module dependency 
which downloads only the artifact file with the specified extension. Existing 
module descriptors are ignored.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=ssub:classifiers></A>44.4.1.3.&nbsp;Classifiers</H4></DIV></DIV></DIV>
<P>The Maven dependency management has the notion of classifiers.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SUP>[<A class=footnote 
href="#ftn.N14067" name=N14067>13</A>]</SUP><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>Gradle supports this. To retrieve 
classified dependencies from a maven repository you can write:</P>
<DIV class=example><A name=classifier></A>
<P class=title><B>Example&nbsp;44.6.&nbsp;Dependency with classifier</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>compile <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.gradle.test.classifiers:service:1.0:jdk15@jar"</SPAN>
    otherConf group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.gradle.test.classifiers'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'service'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'1.0'</SPAN>, classifier: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'jdk14'</SPAN></PRE></DIV></DIV><BR 
class=example-break>
<P>As you can see in the example, classifiers can be used together with setting 
an explicit extension (artifact only notation).</P></DIV>
<P>To use the external dependencies of a configuration:</P>
<DIV class=example><A name=externalDependencies></A>
<P class=title><B>Example&nbsp;44.7.&nbsp;Usage of external dependency of a 
configuration</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task listJars &lt;&lt; {
    configurations.compile.each { File file -&gt; println file.name }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q listJars</CODE></STRONG></P><PRE class=screen>&gt; gradle -q listJars
hibernate-core-3.6.7.Final.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
slf4j-api-1.6.1.jar
hibernate-commons-annotations-3.2.0.Final.jar
hibernate-jpa-2.0-api-1.0.1.Final.jar
jta-1.1.jar</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:client_module_dependencies></A>44.4.2.&nbsp;Client 
module dependencies</H3></DIV></DIV></DIV>
<P>Client module dependencies enable you to declare<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>transitive</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>dependencies directly in your build 
script. They are a replacement for a module descriptor XML file in an external 
repository.</P>
<DIV class=example><A name=client-modules></A>
<P class=title><B>Example&nbsp;44.8.&nbsp;Client module dependencies - 
transitive dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime module(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.codehaus.groovy:groovy-all:1.8.8"</SPAN>) {
        dependency(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"commons-cli:commons-cli:1.0"</SPAN>) {
            transitive = false
        }
        module(group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.apache.ant'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'ant'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'1.8.4'</SPAN>) {
            dependencies <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.apache.ant:ant-launcher:1.8.4@jar"</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.apache.ant:ant-junit:1.8.4"</SPAN>
        }
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>This declares a dependency of your project on Groovy. Groovy itself has 
dependencies. But Gradle does not look for an XML descriptor to figure them out 
but gets the information from the build file. The dependencies of a client 
module can be normal module dependencies or artifact dependencies or another 
client module. Have also a look at the API documentation:<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target=_top><CODE 
class=classname>ClientModule</CODE></A></P>
<P>In the current release client modules have one limitation. Let's say your 
project is a library and you want this library to be uploaded to your company's 
Maven or Ivy repository. Gradle uploads the jars of your project to the company 
repository together with the XML descriptor file of the dependencies. If you use 
client modules the dependency declaration in the XML descriptor file is not 
correct. We will improve this in a future release of Gradle.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:project_dependencies></A>44.4.3.&nbsp;Project 
dependencies</H3></DIV></DIV></DIV>
<P>Gradle distinguishes between external dependencies and dependencies on 
projects which are part of the same multi-project build. For the latter you can 
declare<SPAN class=Apple-converted-space>&nbsp;</SPAN><EM 
class=firstterm>Project Dependencies</EM>.</P>
<DIV class=example><A name=project-dependencies></A>
<P class=title><B>Example&nbsp;44.9.&nbsp;Project dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    compile project(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">':shared'</SPAN>)
}</PRE></DIV></DIV><BR class=example-break>
<P>For more information see the API documentation for<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" 
target=_top><CODE class=classname>ProjectDependency</CODE></A></P>
<P>Multi-project builds are discussed in<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="multi_project_builds.html">Chapter&nbsp;50,<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><I>Multi-project 
Builds</I></A>.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:file_dependencies></A>44.4.4.&nbsp;File 
dependencies</H3></DIV></DIV></DIV>
<P>File dependencies allow you to directly add a set of files to a 
configuration, without first adding them to a repository. This can be useful if 
you cannot, or do not want to, place certain files in a repository. Or if you do 
not want to use any repositories at all for storing your dependencies.</P>
<P>To add some files as a dependency for a configuration, you simply pass a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=link 
href="working_with_files.html#sec_file_collections">file collection</A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>as a dependency:</P>
<DIV class=example><A name=file-dependencies></A>
<P class=title><B>Example&nbsp;44.10.&nbsp;File dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime files(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'libs/a.jar'</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'libs/b.jar'</SPAN>)
    runtime fileTree(dir: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'libs'</SPAN>, include: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'*.jar'</SPAN>)
}</PRE></DIV></DIV><BR class=example-break>
<P>File dependencies are not included in the published dependency descriptor for 
your project. However, file dependencies are included in transitive project 
dependencies within the same build. This means they cannot be used outside the 
current build, but they can be used with the same build.</P>
<P>You can declare which tasks produce the files for a file dependency. You 
might do this when, for example, the files are generated by the build.</P>
<DIV class=example><A name=generatedFileDependencies></A>
<P class=title><B>Example&nbsp;44.11.&nbsp;Generated file dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    compile files(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"$buildDir/classes"</SPAN>) {
        builtBy <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'compile'</SPAN>
    }
}

task compile &lt;&lt; {
    println <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'compiling classes'</SPAN>
}

task list(dependsOn: configurations.compile) &lt;&lt; {
    println <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"classpath = ${configurations.compile.collect {File file -&gt; file.name}}"</SPAN>
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q list</CODE></STRONG></P><PRE class=screen>&gt; gradle -q list
compiling classes
classpath = [classes]</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:api_dependencies></A>44.4.5.&nbsp;Gradle API 
Dependency</H3></DIV></DIV></DIV>
<P>You can declare a dependency on the API of the current version of Gradle by 
using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" 
target=_top><CODE class=classname>DependencyHandler.gradleApi()</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method. This is useful when you are 
developing custom Gradle tasks or plugins.</P>
<DIV class=example><A name=gradle-api-dependencies></A>
<P class=title><B>Example&nbsp;44.12.&nbsp;Gradle API dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    compile gradleApi()
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:groovy_dependencies></A>44.4.6.&nbsp;Local Groovy 
Dependency</H3></DIV></DIV></DIV>
<P>You can declare a dependency on the Groovy that is distributed with Gradle by 
using the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" 
target=_top><CODE 
class=classname>DependencyHandler.localGroovy()</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method. This is useful when you are 
developing custom Gradle tasks or plugins in Groovy.</P>
<DIV class=example><A name=local-groovy-dependencies></A>
<P class=title><B>Example&nbsp;44.13.&nbsp;Gradle's Groovy dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    groovy localGroovy()
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sub:exclude_transitive_dependencies></A>44.4.7.&nbsp;Excluding transitive 
dependencies</H3></DIV></DIV></DIV>
<P>You can exclude a<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>transitive</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>dependency either by configuration or 
by dependency:</P>
<DIV class=example><A name=exclude-dependencies></A>
<P class=title><B>Example&nbsp;44.14.&nbsp;Excluding transitive 
dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations {
    compile.exclude module: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'commons'</SPAN>
    all*.exclude group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.gradle.test.excludes'</SPAN>, module: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'reports'</SPAN>
}

dependencies {
    compile(<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.gradle.test.excludes:api:1.0"</SPAN>) {
        exclude module: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'shared'</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>If you define an exclude for a particular configuration, the excluded 
transitive dependency will be filtered for all dependencies when resolving this 
configuration or any inheriting configuration. If you want to exclude a 
transitive dependency from all your configurations you can use the Groovy 
spread-dot operator to express this in a concise way, as shown in the example. 
When defining an exclude, you can specify either only the organization or only 
the module name or both. Have also a look at the API documentation of<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/Dependency.html" target=_top><CODE 
class=classname>Dependency</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>and<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.Configuration.html" target=_top><CODE 
class=classname>Configuration</CODE></A>.</P>
<P>Not every transitive dependency can be excluded - some transitive 
dependencies might be essential for correct runtime behavior of the application. 
Generally, one can exclude transitive dependencies that are either not required 
by runtime or that are guaranteed to be available on the target 
environment/platform.</P>
<P>Should you exclude per-dependency or per-configuration? It turns out that in 
majority of cases you want to use the per-configuration exclusion. Here are the 
some exemplary reasons why one might want to exclude a transitive dependency. 
Bear in mind that for some of those use cases there are better solutions than 
exclusions!</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>The dependency is undesired due to licensing reasons.</LI>
  <LI class=listitem>The dependency is not available in any of remote 
  repositories.</LI>
  <LI class=listitem>The dependency is not needed for runtime.</LI>
  <LI class=listitem>The dependency has a version that conflicts with a desired 
  version. For that use case please refer to<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
  href="dependency_management.html#sub:version_conflicts">Section&nbsp;44.2.3, 
  “Version conflicts”</A><SPAN class=Apple-converted-space>&nbsp;</SPAN>and the 
  documentation on<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
  href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" 
  target=_top><CODE class=classname>ResolutionStrategy</CODE></A><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>for a potentially better solution to 
  the problem.</LI></UL></DIV>
<P>Basically, in most of the cases excluding the transitive dependency should be 
done per configuration. This way the dependency declaration is more explicit. It 
is also more accurate because a per-dependency exclude rule does not guarantee 
the given transitive dependency does not show up in the configuration. For 
example, some other dependency, which does not have any exclude rules, might 
pull in that unwanted transitive dependency.</P>
<P>Other examples of the dependency exclusions can be found in the reference 
for<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" 
target=_top><CODE class=classname>ModuleDependency</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>or<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" 
target=_top><CODE class=classname>DependencyHandler</CODE></A>.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=N1415C></A>44.4.8.&nbsp;Optional 
attributes</H3></DIV></DIV></DIV>
<P><A name=para:dependencies_with_empty_attributes></A>All attributes for a 
dependency are optional, except the name. It depends on the repository type, 
which information is need for actually finding the dependencies in the 
repository. See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="dependency_management.html#sec_repositories">Section&nbsp;44.6, 
“Repositories”</A>. If you work for example with Maven repositories, you need to 
define the group, name and version. If you work with filesystem repositories you 
might only need the name or the name and the version.</P>
<DIV class=example><A name=dependenciesWithEmptyAttributes></A>
<P class=title><B>Example&nbsp;44.15.&nbsp;Optional attributes of 
dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">":junit:4.10"</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">":testng"</SPAN>
    runtime name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'testng'</SPAN> 
}</PRE></DIV></DIV><BR class=example-break>
<P><A name=para:notation_collections></A>You can also assign collections or 
arrays of dependency notations to a configuration:</P>
<DIV class=example><A name=listGrouping></A>
<P class=title><B>Example&nbsp;44.16.&nbsp;Collections and arrays of 
dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>List groovy = [<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.codehaus.groovy:groovy-all:1.8.8@jar"</SPAN>,
               <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"commons-cli:commons-cli:1.0@jar"</SPAN>,
               <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"org.apache.ant:ant:1.8.4@jar"</SPAN>]
List hibernate = [<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.hibernate:hibernate:3.0.5@jar'</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'somegroup:someorg:1.0@jar'</SPAN>]
dependencies {
    runtime groovy, hibernate
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sec_dependency_configurations></A>44.4.9.&nbsp;Dependency 
configurations</H3></DIV></DIV></DIV>
<P>In Gradle a dependency can have different configurations (as your project can 
have different configurations). If you don't specify anything explicitly, Gradle 
uses the default configuration of the dependency. For dependencies from a Maven 
repository, the default configuration is the only available one anyway. If you 
work with Ivy repositories and want to declare a non-default configuration for 
your dependency you have to use the map notation and declare:</P>
<DIV class=example><A name=dependencyConfigurations></A>
<P class=title><B>Example&nbsp;44.17.&nbsp;Dependency configurations</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    runtime group: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'org.somegroup'</SPAN>, name: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'somedependency'</SPAN>, version: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'1.0'</SPAN>, configuration: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'someConfiguration'</SPAN>
}</PRE></DIV></DIV><BR class=example-break>
<P>To do the same for project dependencies you need to declare:</P>
<DIV class=example><A name=dependencyConfigurationsProjects></A>
<P class=title><B>Example&nbsp;44.18.&nbsp;Dependency configurations for 
project</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>dependencies {
    compile project(path: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">':api'</SPAN>, configuration: <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'spi'</SPAN>)
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=N14198></A>44.4.10.&nbsp;Dependency 
reports</H3></DIV></DIV></DIV>
<P>You can generate dependency reports from the command line (see<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="tutorial_gradle_command_line.html#para:commandline_dependency_report">Section&nbsp;11.6.3, 
“Listing project dependencies”</A>). With the help of the Project report plugin 
(see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="project_reports_plugin.html">Chapter&nbsp;39,<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><I>The Project Report Plugin</I></A>) 
such a report can be created by your build.</P>
<P>Since Gradle 1.2 there is also a new programmatic API to access the resolved 
dependency information. The dependency reports (see the previous paragraph) are 
using this API behind the hood. The API lets you to walk the resolved dependency 
graph and provides information about the dependencies. With the coming releases 
the API will grow to provide more information about the resolution result. For 
more information about the API please refer to the javadocs on<A class=ulink 
href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" 
target=_top><CODE 
class=classname>ResolvableDependencies.getResolutionResult()</CODE></A>. 
Potential usages of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A 
class=ulink 
href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" 
target=_top><CODE class=classname>ResolutionResult</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>API:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>Creation of advanced dependency reports tailored to your 
  use case.</LI>
  <LI class=listitem>Enabling the build logic to make decisions based on the 
  content of the dependency graph.</LI></UL></DIV>
<P></P></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=sec_working_with_dependencies></A>44.5.&nbsp;Working 
with dependencies</H2></DIV></DIV></DIV>
<P>For the examples below we have the following dependencies setup:</P>
<DIV class=example><A name=configurationHandlingSetup></A>
<P class=title><B>Example&nbsp;44.19.&nbsp;Configuration.copy</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations {
    sealife
    alllife
}

dependencies {
    sealife <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"sea.mammals:orca:1.0"</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"sea.fish:shark:1.0"</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"sea.fish:tuna:1.0"</SPAN>
    alllife configurations.sealife
    alllife <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"air.birds:albatros:1.0"</SPAN>
}</PRE></DIV></DIV><BR class=example-break>
<P>The dependencies have the following transitive dependencies:</P>
<P>shark-1.0 -&gt; seal-2.0, tuna-1.0</P>
<P>orca-1.0 -&gt; seal-1.0</P>
<P>tuna-1.0 -&gt; herring-1.0</P>
<P>You can use the configuration to access the declared dependencies or a subset 
of those:</P>
<DIV class=example><A name=configurationHandlingDependencies></A>
<P class=title><B>Example&nbsp;44.20.&nbsp;Accessing declared 
dependencies</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task dependencies &lt;&lt; {
    configurations.alllife.dependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.findAll { dep -&gt; dep.name != <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'orca'</SPAN> }.each { dep -&gt; println dep.name }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q dependencies</CODE></STRONG></P><PRE class=screen>&gt; gradle -q dependencies
albatros

albatros
orca
shark
tuna

albatros
shark
tuna</PRE></DIV></DIV><BR class=example-break>
<P><CODE class=code>dependencies</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>returns only the dependencies belonging 
explicitly to the configuration.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>allDependencies</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>includes the dependencies from extended 
configurations.</P>
<P>To get the library files of the configuration dependencies you can do:</P>
<DIV class=example><A name=configurationHandlingAllFiles></A>
<P class=title><B>Example&nbsp;44.21.&nbsp;Configuration.files</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task allFiles &lt;&lt; {
    configurations.sealife.files.each { file -&gt;
        println file.name
    }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q allFiles</CODE></STRONG></P><PRE class=screen>&gt; gradle -q allFiles
orca-1.0.jar
shark-1.0.jar
tuna-1.0.jar
seal-2.0.jar
herring-1.0.jar</PRE></DIV></DIV><BR class=example-break>
<P>Sometimes you want the library files of a subset of the configuration 
dependencies (e.g. of a single dependency).</P>
<DIV class=example><A name=configurationHandlingFiles></A>
<P class=title><B>Example&nbsp;44.22.&nbsp;Configuration.files with spec</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task files &lt;&lt; {
    configurations.sealife.files { dep -&gt; dep.name == <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'orca'</SPAN> }.each { file -&gt;
        println file.name
    }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q files</CODE></STRONG></P><PRE class=screen>&gt; gradle -q files
orca-1.0.jar
seal-2.0.jar</PRE></DIV></DIV><BR class=example-break>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>Configuration.files</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method always retrieves all artifacts 
of the<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>whole</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>configuration. It then filters the 
retrieved files by specified dependencies. As you can see in the example, 
transitive dependencies are included.</P>
<P>You can also copy a configuration. You can optionally specify that only a 
subset of dependencies from the original configuration should be copied. The 
copying methods come in two flavors. The<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>copy</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method copies only the dependencies 
belonging explicitly to the configuration. The<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>copyRecursive</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method copies all the dependencies, 
including the dependencies from extended configurations.</P>
<DIV class=example><A name=configurationHandlingCopy></A>
<P class=title><B>Example&nbsp;44.23.&nbsp;Configuration.copy</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task copy &lt;&lt; {
    configurations.alllife.copyRecursive { dep -&gt; dep.name != <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'orca'</SPAN> }.allDependencies.each { dep -&gt;
        println dep.name
    }
    println()
    configurations.alllife.copy().allDependencies.each { dep -&gt;
        println dep.name
    }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q copy</CODE></STRONG></P><PRE class=screen>&gt; gradle -q copy
albatros
shark
tuna

albatros</PRE></DIV></DIV><BR class=example-break>
<P>It is important to note that the returned files of the copied configuration 
are often but not always the same than the returned files of the dependency 
subset of the original configuration. In case of version conflicts between 
dependencies of the subset and dependencies not belonging to the subset the 
resolve result might be different.</P>
<DIV class=example><A name=configurationHandlingCopyVsFiles></A>
<P class=title><B>Example&nbsp;44.24.&nbsp;Configuration.copy vs. 
Configuration.files</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>task copyVsFiles &lt;&lt; {
    configurations.sealife.copyRecursive { dep -&gt; dep.name == <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'orca'</SPAN> }.each { file -&gt;
        println file.name
    }
    println()
    configurations.sealife.files { dep -&gt; dep.name == <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'orca'</SPAN> }.each { file -&gt;
        println file.name
    }
}</PRE>
<P>Output of<SPAN class=Apple-converted-space>&nbsp;</SPAN><STRONG 
class=userinput><CODE>gradle -q copyVsFiles</CODE></STRONG></P><PRE class=screen>&gt; gradle -q copyVsFiles
orca-1.0.jar
seal-1.0.jar

orca-1.0.jar
seal-2.0.jar</PRE></DIV></DIV><BR class=example-break>
<P>In the example above,<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>orca</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>has a 
dependency on<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>seal-1.0</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>whereas<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>shark</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>has a dependency on<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>seal-2.0</CODE>. The 
original configuration has therefore a version conflict which is resolved to the 
newer<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>seal-2.0</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>version. The<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>files</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>method therefore returns<CODE 
class=code>seal-2.0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>as a 
transitive dependency of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>orca</CODE>. The copied configuration only has<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=code>orca</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>as a dependency and therefore there is 
no version conflict and<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=code>seal-1.0</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>is 
returned as a transitive dependency.</P>
<P>Once a configuration is resolved it is immutable. Changing its state or the 
state of one of its dependencies will cause an exception. You can always copy a 
resolved configuration. The copied configuration is in the unresolved state and 
can be freshly resolved.</P>
<P>To learn more about the API of the configuration class see the API 
documentation:<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.Configuration.html" target=_top><CODE 
class=classname>Configuration</CODE></A>.</P></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=sec_repositories></A>44.6.&nbsp;Repositories</H2></DIV></DIV></DIV>
<P>Gradle repository management, based on Apache Ivy, gives you a lot of freedom 
regarding repository layout and retrieval policies. Additionally Gradle provides 
various convenience method to add pre-configured repositories.</P>
<P>You may configure any number of repositories, each of which is treated 
independently by Gradle. If Gradle finds a module descriptor in a particular 
repository, it will attempt to download all of the artifacts for that module 
from<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>the 
same repository</EM></SPAN>. Although module meta-data and module artifacts must 
be located in the same repository, it is possible to compose a single repository 
of multiple URLs, giving multiple locations to search for meta-data files and 
jar files.</P>
<P>There are several different types of repositories you can declare:</P>
<DIV class=table xmlns:xslthl="http://xslthl.sf.net">
<P class=title><B>Table&nbsp;44.2.&nbsp;Repository types</B></P>
<DIV class=table-contents>
<TABLE id=N14272>
  <THEAD>
  <TR>
    <TD>Type</TD>
    <TD>Description</TD></TR></THEAD>
  
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sub:maven_central">Maven central 
      repository</A></TD>
    <TD>A pre-configured repository that looks for dependencies in Maven 
      Central.</TD></TR>
  <TR>
    <TD><A class=link href="dependency_management.html#sub:maven_local">Maven 
      local repository</A></TD>
    <TD>A pre-configured repository that looks for dependencies in the local 
      Maven repository.</TD></TR>
  <TR>
    <TD><A class=link href="dependency_management.html#sub:maven_repo">Maven 
      repository</A></TD>
    <TD>A Maven repository. Can be located on the local filesystem or at some 
      remote location.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sec_ivy_repositories">Ivy 
    repository</A></TD>
    <TD>An Ivy repository. Can be located on the local filesystem or at some 
      remote location.</TD></TR>
  <TR>
    <TD><A class=link 
      href="dependency_management.html#sec_flat_dir_resolver">Flat directory 
      repository</A></TD>
    <TD>A simple repository on the local filesystem. Does not support any 
      meta-data formats.</TD></TR></TABLE></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:maven_central></A>44.6.1.&nbsp;Maven central 
repository</H3></DIV></DIV></DIV>
<P>To add the central Maven 2 repository (<A class=ulink 
href="http://repo1.maven.org/maven2" 
target=_top>http://repo1.maven.org/maven2</A>) simply add this to your build 
script:</P>
<DIV class=example><A name=mavenCentral></A>
<P class=title><B>Example&nbsp;44.25.&nbsp;Adding central Maven 
repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    mavenCentral()
}</PRE></DIV></DIV><BR class=example-break>
<P>Now Gradle will look for your dependencies in this repository.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:maven_local></A>44.6.2.&nbsp;Local Maven 
repository</H3></DIV></DIV></DIV>
<P>To use the local Maven cache as a repository you can do:</P>
<DIV class=example><A name=mavenLocalRepo></A>
<P class=title><B>Example&nbsp;44.26.&nbsp;Adding the local Maven cache as a 
repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    mavenLocal()
}</PRE></DIV></DIV><BR class=example-break>
<P>Gradle uses the same logic as maven to identify the location of your local 
maven cache. If a local repository location is defined in a<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=filename>settings.xml</CODE>, this location will be used. The<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=filename>settings.xml</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>in<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=filename><EM 
class=replaceable><CODE>USER_HOME</CODE></EM>/.m2</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>takes precedence over the<CODE 
class=filename>settings.xml</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>in<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=filename><EM 
class=replaceable><CODE>M2_HOME</CODE></EM>/conf</CODE>. If no<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=filename>settings.xml</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>is available, Gradle uses the default 
location<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE class=filename><EM 
class=replaceable><CODE>USER_HOME</CODE></EM>/.m2/repository</CODE>.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:maven_repo></A>44.6.3.&nbsp;Maven 
repositories</H3></DIV></DIV></DIV>
<P>For adding a custom Maven repository you can do:</P>
<DIV class=example><A name=mavenLikeRepo></A>
<P class=title><B>Example&nbsp;44.27.&nbsp;Adding custom Maven 
repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    maven {
        url <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/maven2"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>Sometimes a repository will have the POMs published to one location, and the 
JARs and other artifacts published at another location. To define such a 
repository, you can do:</P>
<DIV class=example><A name=mavenLikeRepoWithJarRepo></A>
<P class=title><B>Example&nbsp;44.28.&nbsp;Adding additional Maven repositories 
for JAR files</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    maven {
        <SPAN class=hl-comment xmlns:xslthl="http://xslthl.sf.net">// Look for POMs and artifacts, such as JARs, here</SPAN>
        url <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo2.mycompany.com/maven2"</SPAN>
        <SPAN class=hl-comment xmlns:xslthl="http://xslthl.sf.net">// Look for artifacts here if not found at the above location</SPAN>
        artifactUrls <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/jars"</SPAN>
        artifactUrls <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/jars2"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>Gradle will look at the first URL for the POM and the JAR. If the JAR can't 
be found there, the artifact URLs are used to look for JARs.</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=N14310></A>44.6.3.1.&nbsp;Accessing password protected 
Maven repositories</H4></DIV></DIV></DIV>
<P>To access a Maven repository which uses basic authentication, you specify the 
username and password to use when you define the repository:</P>
<DIV class=example><A name=mavenPasswordProtectedRepo></A>
<P class=title><B>Example&nbsp;44.29.&nbsp;Accessing password protected Maven 
repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    maven {
        credentials {
            username <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'user'</SPAN>
            password <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'password'</SPAN>
        }
        url <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/maven2"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>It is advisable to keep your username and password in<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=filename>gradle.properties</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>rather than directly in the build 
file.</P></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sec_flat_dir_resolver></A>44.6.4.&nbsp;Flat directory 
repository</H3></DIV></DIV></DIV>
<P>If you want to use a (flat) filesystem directory as a repository, simply 
type:</P>
<DIV class=example><A name=flatDirMulti></A>
<P class=title><B>Example&nbsp;44.30.&nbsp;Flat repository resolver</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    flatDir {
        dirs <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'lib'</SPAN>
    }
    flatDir {
        dirs <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'lib1'</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'lib2'</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>This adds repositories which look into one or more directories for finding 
dependencies. If you only work with flat directory resolvers you don't need to 
set all attributes of a dependency. See<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="dependency_management.html#para:dependencies_with_empty_attributes">Section&nbsp;44.4.8, 
“Optional attributes”</A></P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sec_ivy_repositories></A>44.6.5.&nbsp;Ivy 
repositories</H3></DIV></DIV></DIV>
<P>To use an Ivy repository with a standard layout:</P>
<DIV class=example><A name=ivyRepository></A>
<P class=title><B>Example&nbsp;44.31.&nbsp;Ivy repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    ivy {
        url <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/repo"</SPAN>
        layout <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"maven"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>See<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../javadoc/org/gradle/api/artifacts/repositories/IvyArtifactRepository.html" 
target=_top><CODE class=classname>IvyArtifactRepository</CODE></A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>for details.</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=N14350></A>44.6.5.1.&nbsp;Defining custom patterns for 
an Ivy repository</H4></DIV></DIV></DIV>
<P>To define an Ivy repository with a non-standard layout, you can define a 
pattern layout for the repository:</P>
<DIV class=example><A name=ivyRepository></A>
<P class=title><B>Example&nbsp;44.32.&nbsp;Ivy repository with pattern 
layout</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    ivy {
        url <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/repo"</SPAN>
        layout <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'pattern'</SPAN>, {
            artifact <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"[module]/[revision]/[artifact].[ext]"</SPAN>
            ivy <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"[module]/[revision]/ivy.xml"</SPAN>
        }
    }
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=N1435F></A>44.6.5.2.&nbsp;Defining different artifact 
and ivy file locations for an Ivy repository</H4></DIV></DIV></DIV>
<P>To define an Ivy repository which fetches ivy files and artifacts from 
different locations, you can explicitly define complete URL patterns for 
artifacts and ivy files:</P>
<DIV class=example><A name=ivyRepository></A>
<P class=title><B>Example&nbsp;44.33.&nbsp;Ivy repository with custom 
patterns</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    ivy {
        artifactPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</SPAN>
        artifactPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</SPAN>
        ivyPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/ivy-files/[organisation]/[module]/[revision]/ivy.xml"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>Each<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>ivyPattern</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>or<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>artifactPattern</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>specified for a repository adds an<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>additional</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>pattern, on top of any url/layout based 
patterns defined. Values supplied as<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>ivyPattern</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>or<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>artifactPattern</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>should be fully qualified URLs as they 
are not resolved relative to the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>url</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>parameter for the repository. Any 
unqualified patterns will be resolved as a file path, relative to the project 
base directory.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=N14382></A>44.6.5.3.&nbsp;Accessing password protected 
Ivy repositories</H4></DIV></DIV></DIV>
<P>To access an Ivy repository which uses basic authentication, you specify the 
username and password to use when you define the repository:</P>
<DIV class=example><A name=ivyRepository></A>
<P class=title><B>Example&nbsp;44.34.&nbsp;Ivy repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    ivy {
        credentials {
            username <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'user'</SPAN>
            password <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'password'</SPAN>
        }
        artifactPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"http://repo.mycompany.com/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=N14391></A>44.6.6.&nbsp;Working with 
repositories</H3></DIV></DIV></DIV>
<P>To access a repository:</P>
<DIV class=example><A name=defineRepository></A>
<P class=title><B>Example&nbsp;44.35.&nbsp;Accessing a repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>println repositories.localRepository.name
    println repositories[<SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'localRepository'</SPAN>].name</PRE></DIV></DIV><BR 
class=example-break>
<P>To configure a repository:</P>
<DIV class=example><A name=defineRepository></A>
<P class=title><B>Example&nbsp;44.36.&nbsp;Configuration of a repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    flatDir {
        name <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'localRepository'</SPAN>
    }
}
repositories {
    localRepository {
        dirs <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'lib'</SPAN>
    }
}
repositories.localRepository {
    dirs <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'lib'</SPAN>
}</PRE></DIV></DIV><BR class=example-break></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sub:more_about_ivy_resolvers></A>44.6.7.&nbsp;More about 
Ivy resolvers</H3></DIV></DIV></DIV>
<P>Gradle, thanks to Ivy under its hood, is extremely flexible regarding 
repositories:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>There are many options for the protocol to communicate with the repository 
  (e.g. filesystem, http, ssh, ...)</P></LI>
  <LI class=listitem>
  <P>Each repository can have its own layout.</P></LI></UL></DIV>
<P>Let's say, you declare a dependency on the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>junit:junit:3.8.2</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>library. Now how does Gradle find it in 
the repositories? Somehow the dependency information has to be mapped to a path. 
In contrast to Maven, where this path is fixed, with Gradle you can define a 
pattern that defines what the path will look like. Here are some examples:<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SUP>[<A class=footnote 
href="#ftn.N143BE" name=N143BE>14</A>]</SUP></P><PRE class=programlisting>// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]</PRE>
<P>To add any kind of repository (you can pretty easy write your own ones) you 
can do:</P>
<DIV class=example><A name=fileSystemResolver></A>
<P class=title><B>Example&nbsp;44.37.&nbsp;Definition of a custom 
repository</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>repositories {
    ivy {
        ivyPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"$projectDir/repo/[organisation]/[module]-ivy-[revision].xml"</SPAN>
        artifactPattern <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">"$projectDir/repo/[organisation]/[module]-[revision](-[classifier]).[ext]"</SPAN>
    }
}</PRE></DIV></DIV><BR class=example-break>
<P>An overview of which Resolvers are offered by Ivy and thus also by Gradle can 
be found<SPAN class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" 
target=_top>here</A>. With Gradle you just don't configure them via XML but 
directly via their API.</P></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=sec_dependency_resolution></A>44.7.&nbsp;How dependency 
resolution works</H2></DIV></DIV></DIV>
<P>Gradle takes your dependency declarations and repository definitions and 
attempts to download all of your dependencies by a process called<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>dependency 
resolution</EM></SPAN>. Below is a brief outline of how this process works.</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>Given a required dependency, Gradle first attempts to resolve the<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN 
  class=emphasis><EM>module</EM></SPAN><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>for that dependency. Each repository 
  is inspected in order, searching first for a<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>module 
  descriptor</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>file (pom 
  or ivy file) that indicates the presence of that module. If no module 
  descriptor is found, Gradle will search for the presence of the primary<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>module 
  artifact</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>file 
  indicating that the module exists in the repository.</P>
  <DIV class=itemizedlist>
  <UL class=itemizedlist>
    <LI class=listitem>
    <P>If the dependency is declared as a dynamic version (like<SPAN 
    class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>1.+</CODE>), 
    Gradle will resolve this to the newest available static version (like<SPAN 
    class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>1.2</CODE>) in 
    the repository. For maven repositories, this is done using the<SPAN 
    class=Apple-converted-space>&nbsp;</SPAN><CODE 
    class=literal>maven-metadata.xml</CODE><SPAN 
    class=Apple-converted-space>&nbsp;</SPAN>file, while for ivy repositories 
    this is done by directory listing.</P></LI>
    <LI class=listitem>
    <P>If the module descriptor is a<SPAN 
    class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>pom</CODE><SPAN 
    class=Apple-converted-space>&nbsp;</SPAN>file that has a parent pom 
    declared, Gradle will recursively attempt to resolve each of the parent 
    modules for the pom.</P></LI></UL></DIV></LI>
  <LI class=listitem>
  <P>Once each repository has been inspected for the module, Gradle will choose 
  the 'best' one to use. This is done using the following criteria:</P>
  <DIV class=itemizedlist>
  <UL class=itemizedlist>
    <LI class=listitem>For a dynamic version, a 'higher' static version is 
    preferred over a 'lower' version.</LI>
    <LI class=listitem>Modules declared by a module descriptor file (ivy or pom 
    file) are preferred over modules that have an artifact file only.</LI>
    <LI class=listitem>Modules from earlier repositories are preferred over 
    modules in later repositories.</LI></UL></DIV>
  <P></P>
  <P>When the dependency is declared by a static version and a module descriptor 
  file is found in a repository, there is no need to continue searching later 
  repositories and the remainder of the process is short-circuited.</P></LI>
  <LI class=listitem>
  <P>All of the artifacts for the module are then requested from the<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>same 
  repository</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>that was 
  chosen in the process above.</P></LI></UL></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A name=sec_dependency_cache></A>44.8.&nbsp;The dependency 
cache</H2></DIV></DIV></DIV>
<P>Gradle contains a highly sophisticated dependency caching mechanism, which 
seeks to minimise the number of remote requests made in dependency resolution, 
while striving to guarantee that the results of dependency resolution are 
correct and reproducible.</P>
<P>The Gradle dependency cache consists of 2 key types of storage:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>A file-based store of downloaded artifacts, including binaries like jars as 
  well as raw downloaded meta-data like pom files and ivy files. The storage 
  path for a downloaded artifact includes the SHA1 checksum, meaning that 2 
  artifacts with the same name but different content can easily be 
  cached.</P></LI>
  <LI class=listitem>
  <P>A binary store of resolved module meta-data, including the results of 
  resolving dynamic versions, module descriptors, and 
artifacts.</P></LI></UL></DIV>
<P>Separating the storage of downloaded artifacts from the cache metadata 
permits us to do some very powerful things with our cache that would be 
difficult with a transparent, file-only cache layout.</P>
<P>The Gradle cache does not allow the local cache to hide problems and creating 
mysterious and difficult to debug behavior that has been a challenge with many 
build tools. This new behavior is implemented in a bandwidth and storage 
efficient way. In doing so, Gradle enables reliable and reproducible enterprise 
builds.</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sec_cache_features></A>44.8.1.&nbsp;Key features of the 
Gradle dependency cache</H3></DIV></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=sub:cache_metadata></A>44.8.1.1.&nbsp;Separate metadata 
cache</H4></DIV></DIV></DIV>
<P>Gradle keeps a record of various aspects of dependency resolution in binary 
format in the metadata cache. The information stored in the metadata cache 
includes:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>The result of resolving a dynamic version (eg 1.+) to a 
  concrete version (eg 1.2).</LI>
  <LI class=listitem>The resolved module metadata for a particular module, 
  including module artifacts and module dependencies.</LI>
  <LI class=listitem>The resolved artifact metadata for a particular artifact, 
  including a pointer to the downloaded artifact file.</LI>
  <LI class=listitem>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
  class=emphasis><EM>absence</EM></SPAN><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>of a particular module or artifact in 
  a particular repository, eliminating repeated attempts to access a resource 
  that does not exist.</LI></UL></DIV>
<P>Every entry in the metadata cache includes a record of the repository that 
provided the information as well as a timestamp that can be used for cache 
expiry.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=sub:cache_repository_independence></A>44.8.1.2.&nbsp;Repository caches are 
independent</H4></DIV></DIV></DIV>
<P>As described above, for each repository there is a separate metadata cache. A 
repository is identified by its URL, type and layout. If a module or artifact 
has not been previously resolved from<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>this 
repository</EM></SPAN>, Gradle will attempt to resolve the module against the 
repository. This will always involve a remote lookup on the repository, however 
in many cases no download will be required (see<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="dependency_management.html#sub:cache_artifact_reuse">Section&nbsp;44.8.1.3, 
“Artifact reuse”</A>, below).</P>
<P>Dependency resolution will fail if the required artifacts are not available 
in any repository specified by the build, regardless whether the local cache has 
retrieved this artifact from a different repository. Repository independence 
allows builds to be isolated from each other in an advanced way that no build 
tool has done before. This is a key feature to create builds that are reliable 
and reproducible in any environment.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=sub:cache_artifact_reuse></A>44.8.1.3.&nbsp;Artifact 
reuse</H4></DIV></DIV></DIV>
<P>Before downloading an artifact, Gradle tries to determine the checksum of the 
required artifact by downloading the sha file associated with that artifact. If 
the checksum can be retrieved, an artifact is not downloaded if an artifact 
already exists with the same id and checksum. If the checksum cannot be 
retrieved from the remote server, the artifact will be downloaded (and ignored 
if it matches an existing artifact).</P>
<P>As well as considering artifacts downloaded from a different repository, 
Gradle will also attempt to reuse artifacts found in the local Maven Repository. 
If a candidate artifact has been downloaded by Maven, Gradle will use this 
artifact if it can be verified to match the checksum declared by the remote 
server.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=sub:cache_checksum_storage></A>44.8.1.4.&nbsp;Checksum 
based storage</H4></DIV></DIV></DIV>
<P>It is possible for different repositories to provide a different binary 
artifact in response to the same artifact identifier. This is often the case 
with Maven SNAPSHOT artifacts, but can also be true for any artifact which is 
republished without changing it's identifier. By caching artifacts based on 
their SHA1 checksum, Gradle is able to maintain multiple versions of the same 
artifact. This means that when resolving against one repository Gradle will 
never overwrite the cached artifact file from a different repository. This is 
done without requiring a separate artifact file store per repository.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A name=sub:cache_locking></A>44.8.1.5.&nbsp;Cache 
Locking</H4></DIV></DIV></DIV>
<P>The Gradle dependency cache uses file-based locking to ensure that it can 
safely be used by multiple Gradle processes concurrently. The lock is held 
whenever the binary meta-data store is being read or written, but is released 
for slow operations such as downloading remote artifacts.</P></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sec_cache_command_line_options></A>44.8.2.&nbsp;Command 
line options to override caching</H3></DIV></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=sub:cache_offline></A>44.8.2.1.&nbsp;Offline</H4></DIV></DIV></DIV>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>--offline</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>command line switch tells Gradle to 
always use dependency modules from the cache, regardless if they are due to be 
checked again. When running with offline, Gradle will never attempt to access 
the network to perform dependency resolution. If required modules are not 
present in the dependency cache, build execution will fail.</P></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H4 class=title><A 
name=sub:cache_refresh></A>44.8.2.2.&nbsp;Refresh</H4></DIV></DIV></DIV>
<P>At times, the Gradle Dependency Cache can be out of sync with the actual 
state of the configured repositories. Perhaps a repository was initially 
misconfigured, or perhaps a "non-changing" module was published incorrectly. To 
refresh all dependencies in the dependency cache, use the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>--refresh-dependencies</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>option on the command line.</P>
<P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>--refresh-dependencies</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>option tells Gradle to ignore all 
cached entries for resolved modules and artifacts. A fresh resolve will be 
performed against all configured repositories, with dynamic versions 
recalculated, modules refreshed, and artifacts downloaded. However, where 
possible Gradle will attempt to if the previously downloaded artifacts are valid 
before downloading again. This is done by comparing published SHA1 values in the 
repository with the SHA1 values for existing downloaded 
artifacts.</P></DIV></DIV>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A name=sec_controlling_caching></A>44.8.3.&nbsp;Fine-tuned 
control over dependency caching</H3></DIV></DIV></DIV>
<P>You can fine-tune certain aspects of caching using the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>ResolutionStrategy</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>for a configuration.</P>
<P>By default, Gradle caches dynamic versions for 24 hours. To change how long 
Gradle will cache the resolved version for a dynamic version, use:</P>
<DIV class=example><A name=dynamic-version-cache-control></A>
<P class=title><B>Example&nbsp;44.38.&nbsp;Dynamic version cache control</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <SPAN class=hl-number xmlns:xslthl="http://xslthl.sf.net">10</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'minutes'</SPAN>
}</PRE></DIV></DIV><BR class=example-break>
<P>By default, Gradle caches changing modules for 24 hours. To change how long 
Gradle will cache the meta-data and artifacts for a changing module, use:</P>
<DIV class=example><A name=changing-module-cache-control></A>
<P class=title><B>Example&nbsp;44.39.&nbsp;Changing module cache control</B></P>
<DIV class=example-contents>
<P><CODE class=filename>build.gradle</CODE></P><PRE class=programlisting>configurations.all {
    resolutionStrategy.cacheChangingModulesFor <SPAN class=hl-number xmlns:xslthl="http://xslthl.sf.net">30</SPAN>, <SPAN class=hl-string xmlns:xslthl="http://xslthl.sf.net">'days'</SPAN>
}</PRE></DIV></DIV><BR class=example-break>
<P>For more details, take a look at the API documentation for<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target=_top><CODE 
class=classname>ResolutionStrategy</CODE></A>.</P></DIV></DIV>
<DIV class=section 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px">
<DIV class=titlepage>
<DIV>
<DIV>
<H2 class=title><A 
name=sec_strategies_of_transitive_dependency_management></A>44.9.&nbsp;Strategies 
for transitive dependency management</H2></DIV></DIV></DIV>
<P>Many projects rely on the<SPAN class=Apple-converted-space>&nbsp;</SPAN><A 
class=ulink href="http://repo1.maven.org/maven2" target=_top>Maven Central 
repository</A>. This is not without problems.</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>The Maven Central repository can be down or has a very long response 
  time.</P></LI>
  <LI class=listitem>
  <P>The<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>pom.xml</CODE>'s of many projects have wrong information (as one 
  example, the POM of<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>commons-httpclient-3.0</CODE><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>declares JUnit as a runtime 
  dependency).</P></LI>
  <LI class=listitem>
  <P>For many projects there is not one right set of dependencies (as more or 
  less imposed by the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>pom</CODE><SPAN 
  class=Apple-converted-space>&nbsp;</SPAN>format).</P></LI></UL></DIV>
<P>If your project relies on the Maven Central repository you are likely to need 
an additional custom repository, because:</P>
<DIV class=itemizedlist>
<UL class=itemizedlist>
  <LI class=listitem>
  <P>You might need dependencies that are not uploaded to Maven Central 
  yet.</P></LI>
  <LI class=listitem>
  <P>You want to deal properly with wrong metadata in a Maven Central<SPAN 
  class=Apple-converted-space>&nbsp;</SPAN><CODE 
  class=literal>pom.xml</CODE>.</P></LI>
  <LI class=listitem>
  <P>You don't want to expose people who want to build your project, to the 
  downtimes or sometimes very long response times of Maven 
Central.</P></LI></UL></DIV>
<P>It is not a big deal to set-up a custom repository.<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SUP>[<A class=footnote 
href="#ftn.N144D2" name=N144D2>15</A>]</SUP><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>But it can be tedious, to keep it up to 
date. For a new version, you have always to create the new XML descriptor and 
the directories. And your custom repository is another infrastructure element 
which might have downtimes and needs to be updated. To enable historical builds, 
you need to keep all the past libraries and you need a backup. It is another 
layer of indirection. Another source of information you have to lookup. All this 
is not really a big deal but in its sum it has an impact. Repository Manager 
like Artifactory or Nexus make this easier. But for example open source projects 
don't usually have a host for those products.</P>
<P>This is a reason why some projects prefer to store their libraries in their 
version control system. This approach is fully supported by Gradle. The 
libraries can be stored in a flat directory without any XML module descriptor 
files. Yet Gradle offers complete transitive dependency management. You can use 
either client module dependencies to express the dependency relations, or 
artifact dependencies in case a first level dependency has no transitive 
dependencies. People can check out such a project from svn and have everything 
necessary to build it.</P>
<P>If you are working with a distributed version control system like Git you 
probably don't want to use the version control system to store libraries as 
people check out the whole history. But even here the flexibility of Gradle can 
make your life easier. For example you can use a shared flat directory without 
XML descriptors and yet you can have full transitive dependency management as 
described above.</P>
<P>You could also have a mixed strategy. If your main concern is bad metadata in 
the<SPAN class=Apple-converted-space>&nbsp;</SPAN><CODE 
class=literal>pom.xml</CODE><SPAN class=Apple-converted-space>&nbsp;</SPAN>and 
maintaining custom XML descriptors,<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>Client 
Modules</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>offer an 
alternative. But you can of course still use Maven2 repo and your custom 
repository as a repository for<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN class=emphasis><EM>jars 
only</EM></SPAN><SPAN class=Apple-converted-space>&nbsp;</SPAN>and still 
enjoy<SPAN class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>transitive</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>dependency management. Or you can only 
provide client modules for POMs with bad metadata. For the jars and the correct 
POMs you still use the remote repository.</P>
<DIV class=section>
<DIV class=titlepage>
<DIV>
<DIV>
<H3 class=title><A 
name=sub:implicit_transitive_dependencies></A>44.9.1.&nbsp;Implicit transitive 
dependencies</H3></DIV></DIV></DIV>
<P>There is another way to deal with transitive dependencies<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><SPAN 
class=emphasis><EM>without</EM></SPAN><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>XML descriptor files. You can do this 
with Gradle, but we don't recommend it. We mention it for the sake of 
completeness and comparison with other build tools.</P>
<P>The trick is to use only artifact dependencies and group them in lists. That 
way you have somehow expressed, what are your first level dependencies and what 
are transitive dependencies (see<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=xref 
href="dependency_management.html#para:notation_collections">Section&nbsp;44.4.8, 
“Optional attributes”</A>). But the draw-back is, that for the Gradle dependency 
management all dependencies are considered first level dependencies. The 
dependency reports don't show your real dependency graph and the<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><CODE class=literal>compile</CODE><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>task uses all dependencies, not just 
the first level dependencies. All in all, your build is less maintainable and 
reliable than it could be when using client modules. And you don't gain 
anything.</P></DIV></DIV>
<DIV class=footnotes 
style="WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; COLOR: rgb(0,0,0); FONT: medium Simsun; WIDOWS: 1; LETTER-SPACING: normal; TEXT-INDENT: 0px; -webkit-text-stroke-width: 0px"><BR>
<HR align=left width=100>

<DIV class=footnote>
<P><SUP>[<A class=para href="#N14049" name=ftn.N14049>12</A>]<SPAN 
class=Apple-converted-space>&nbsp;</SPAN></SUP>Gradle supports partial 
multiproject builds (see<SPAN class=Apple-converted-space>&nbsp;</SPAN><A 
class=xref href="multi_project_builds.html">Chapter&nbsp;50,<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><I>Multi-project 
Builds</I></A>).</P></DIV>
<DIV class=footnote>
<P><SUP>[<A class=para href="#N14067" name=ftn.N14067>13</A>]<SPAN 
class=Apple-converted-space>&nbsp;</SPAN></SUP><A class=ulink 
href="http://www.sonatype.com/books/maven-book/reference/pom-relationships-sect-project-relationships.html" 
target=_top>http://www.sonatype.com/books/maven-book/reference/pom-relationships-sect-project-relationships.html</A></P></DIV>
<DIV class=footnote>
<P><SUP>[<A class=para href="#N143BE" name=ftn.N143BE>14</A>]<SPAN 
class=Apple-converted-space>&nbsp;</SPAN></SUP>At<SPAN 
class=Apple-converted-space>&nbsp;</SPAN><A class=ulink 
href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" 
target=_top>http://ant.apache.org/ivy/history/latest-milestone/concept.html</A><SPAN 
class=Apple-converted-space>&nbsp;</SPAN>you can learn more about ivy 
patterns.</P></DIV>
<DIV class=footnote>
<P><SUP>[<A class=para href="#N144D2" name=ftn.N144D2>15</A>]<SPAN 
class=Apple-converted-space>&nbsp;</SPAN></SUP>If you want to shield your 
project from the downtimes of Maven Central things get more complicated. You 
probably want t</P></DIV></DIV></body>
</html>
