<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD id=Head>
<TITLE>JVM启动参数大全</TITLE>
<LINK 
id=MainCss href="style.css" 
type=text/css rel=stylesheet>
<LINK id=RSSLink title=RSS 
href="rss.aspx" type=application/rss+xml 
rel=alternate>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</HEAD>

<BODY>
<FORM id=Form1 name=Form1 action=230265.html?opt=admin method=post 
_initialAction="230265.html?opt=admin">
  <DIV id=centercontent>
    <DIV class=post><!--StartFragment-->
      <DIV class=postTitle><A class=postTitle2 id=viewpost1_TitleUrl 
href="http://www.blogjava.net/midstr/archive/2008/09/21/230265.html">JVM启动参数大全 
        zz</A> </DIV>
      <FONT style="BACKGROUND-COLOR: #cce8cf">jdk1.4.2 JVM官方地址：<FONT 
style="BACKGROUND-COLOR: #cce8cf">http://java.sun.com/j2se/1.4.2/docs/guide/vm/index.html</FONT><BR>
      <FONT 
style="BACKGROUND-COLOR: #cce8cf"><FONT style="BACKGROUND-COLOR: #cce8cf"><FONT 
style="BACKGROUND-COLOR: #cce8cf">标准和非标注参数(for windows)：<A 
href="http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html">http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html</A> </FONT></FONT><BR>
      <FONT style="BACKGROUND-COLOR: #cce8cf"><A 
href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp">非stable参数：http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</A></FONT></FONT><BR>
      <BR>
      中文地址： <BR>
      <SPAN style="COLOR: red"><FONT style="BACKGROUND-COLOR: #cce8cf"><SPAN 
style="COLOR: red"><FONT style="BACKGROUND-COLOR: #cce8cf"><SPAN 
style="COLOR: red"><FONT style="BACKGROUND-COLOR: #cce8cf"><FONT 
style="BACKGROUND-COLOR: #cce8cf"><A 
href="http://blog.csdn.net/sfdev/archive/2008/01/23/2062042.aspx%26nbsp;%26nbsp;%20%26nbsp;http://blog.csdn.net/sfdev/archive/2008/01/24/2063464.aspx">http://blog.csdn.net/sfdev/archive/2008/01/23/2062042.aspx&nbsp;&nbsp;&nbsp;</A></FONT><A 
href="http://blog.csdn.net/sfdev/archive/2008/01/23/2062042.aspx%26nbsp;%26nbsp;%20%26nbsp;http://blog.csdn.net/sfdev/archive/2008/01/24/2063464.aspx"><FONT 
style="BACKGROUND-COLOR: #cce8cf"><FONT color=#000000>&nbsp;</FONT></A></FONT><FONT 
style="BACKGROUND-COLOR: #cce8cf">&nbsp;</FONT></FONT></SPAN></FONT><FONT 
style="BACKGROUND-COLOR: #cce8cf">&nbsp;</FONT></SPAN></FONT></SPAN><SPAN 
style="COLOR: red"><FONT 
style="BACKGROUND-COLOR: #cce8cf">&nbsp;&nbsp;</FONT></SPAN></FONT><FONT 
style="BACKGROUND-COLOR: #cce8cf">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <BR>
      <BR>
      <P>前段时间系统升级时遭遇了OOM，具体解决过程见&nbsp;<A 
href="http://blog.csdn.net/sfdev/archive/2008/01/18/2051171.aspx">遭遇OutOfMemoryError</A>；<BR>
        为了巩固对于java启动各项参数的认识，决定将所有参数列举出来，并一一解释，以便后查；</P>
      <P>java启动参数共分为三类；<BR>
        其一是<STRONG>标准参数</STRONG>（-），所有的JVM实现都必须实现这些参数的功能，而且向后兼容；<BR>
        其二是<STRONG>非标准参数</STRONG>（-X），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容；<BR>
        其三是<STRONG>非Stable参数</STRONG>（-XX），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用；<BR>
        本文主要描述标准参数部分，剩下的两个部分将会陆续推出；</P>
      <P>标准参数列表如下：<BR>
        <STRONG>-client <BR>
      </STRONG>&nbsp;设置jvm使用client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者PC应用开发和调试。</P>
      <P><STRONG>-server</STRONG><BR>
      &nbsp;设置jvm使server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的jdk环境下将默认启用该模式，而忽略-client参数。</P>
      <P><STRONG>-agentlib:libname[=options]</STRONG> <BR>
        &nbsp;用于装载本地lib包；<BR>
        &nbsp;其中libname为本地代理库文件名，默认搜索路径为环境变量PATH中的路径，options为传给本地库启动时的参数，多个参数之间用逗号分隔。在Windows平台上jvm搜索本地库名为libname.dll的文件，在linux上jvm搜索本地库名为libname.so的文件，搜索路径环境变量在不同系统上有所不同，比如Solaries上就默认搜索LD_LIBRARY_PATH。<BR>
        &nbsp;比如：-agentlib:hprof<BR>
      &nbsp;用来获取jvm的运行情况，包括CPU、内存、线程等的运行数据，并可输出到指定文件中；windows中搜索路径为JRE_HOME/bin/hprof.dll。</P>
      <P><STRONG>-agentpath:pathname[=options]</STRONG> <BR>
      &nbsp;按全路径装载本地库，不再搜索PATH中的路径；其他功能和agentlib相同；更多的信息待续，在后续的JVMTI部分会详述。</P>
      <P><STRONG>-classpath classpath <BR>
        -cp classpath</STRONG> <BR>
        &nbsp;告知jvm搜索目录名、jar文档名、zip文档名，之间用分号;分隔；使用-classpath后jvm将不再使用CLASSPATH中的类搜索路径，如果-classpath和CLASSPATH都没有设置，则jvm使用当前路径(.)作为类搜索路径。<BR>
        &nbsp;jvm搜索类的方式和顺序为：Bootstrap，Extension，User。<BR>
        &nbsp;Bootstrap中的路径是jvm自带的jar或zip文件，jvm首先搜索这些包文件，用System.getProperty("sun.boot.class.path")可得到搜索路径。<BR>
        &nbsp;Extension是位于JRE_HOME/lib/ext目录下的jar文件，jvm在搜索完Bootstrap后就搜索该目录下的jar文件，用System.getProperty("java.ext.dirs")可得到搜索路径。<BR>
      &nbsp;User搜索顺序为当前路径.、CLASSPATH、-classpath，jvm最后搜索这些目录，用System.getProperty("java.class.path")可得到搜索路径。</P>
      <P><STRONG>-Dproperty=value</STRONG><BR>
        &nbsp;设置系统属性名/值对，运行在此jvm之上的应用程序可用System.getProperty("property")得到value的值。<BR>
        &nbsp;如果value中有空格，则需要用双引号将该值括起来，如-Dname="space 
        string"。<BR>
      &nbsp;该参数通常用于设置系统级全局变量值，如配置文件路径，以便该属性在程序中任何地方都可访问。</P>
      <P><STRONG>-enableassertions[:&lt;package name&gt;"..." | :&lt;class name&gt; ] <BR>
        -ea[:&lt;package name&gt;"..." | :&lt;class name&gt; ]</STRONG> <BR>
        &nbsp;上述参数就用来设置jvm是否启动断言机制（从JDK 1.4开始支持），缺省时jvm关闭断言机制。<BR>
        &nbsp;用-ea 
        可打开断言机制，不加&lt;packagename&gt;和classname时运行所有包和类中的断言，如果希望只运行某些包或类中的断言，可将包名或类名加到-ea之后。例如要启动包com.wombat.fruitbat中的断言，可用命令java 
        -ea:com.wombat.fruitbat...&lt;Main Class&gt;。</P>
      <P><STRONG>-disableassertions[:&lt;package name&gt;"..." | :&lt;class ; ] <BR>
        -da[:&lt;package name&gt;"..." | :&lt;class name&gt; 
        ]</STRONG><BR>
        &nbsp;用来设置jvm关闭断言处理，packagename和classname的使用方法和-ea相同，jvm默认就是关闭状态。<BR>
        &nbsp;该参数一般用于相同package内某些class不需要断言的场景，比如com.wombat.fruitbat需要断言，但是com.wombat.fruitbat.Brickbat该类不需要，则可以如下运行：<BR>
        &nbsp;java 
        -ea:com.wombat.fruitbat...-da:com.wombat.fruitbat.Brickbat &lt;Main 
        Class&gt;。<BR>
        &nbsp;<BR>
        <STRONG>-enablesystemassertions <BR>
        -esa</STRONG> <BR>
        &nbsp;激活系统类的断言。<BR>
        &nbsp;<BR>
        <STRONG>-disablesystemassertions <BR>
        -dsa</STRONG> <BR>
      &nbsp;关闭系统类的断言。</P>
      <P><STRONG>-jar</STRONG> <BR>
        &nbsp;指定以jar包的形式执行一个应用程序。<BR>
        &nbsp;要这样执行一个应用程序，必须让jar包的manifest文件中声明初始加载的Main-class，当然那Main-class必须有public 
        static void main(String[] args)方法。</P>
      <P><STRONG>-javaagent:jarpath[=options]</STRONG> <BR>
        &nbsp;指定jvm启动时装入java语言设备代理。<BR>
        &nbsp;Jarpath文件中的mainfest文件必须有Agent-Class属性。代理类也必须实现公共的静态public 
        static void premain(String agentArgs, Instrumentation 
        inst)方法（和main方法类似）。当jvm初始化时，将按代理类的说明顺序调用premain方法；具体参见java.lang.instrument软件包的描述。</P>
      <P><STRONG>-verbose <BR>
        -verbose:class</STRONG> <BR>
        &nbsp;输出jvm载入类的相关信息，当jvm报告说找不到类或者类冲突时可此进行诊断。<BR>
        <STRONG>-verbose:gc</STRONG> <BR>
        &nbsp;输出每次GC的相关情况。<BR>
        <STRONG>-verbose:jni</STRONG> <BR>
        &nbsp;输出native方法调用的相关情况，一般用于诊断jni调用错误信息。<BR>
        &nbsp;<BR>
        <STRONG>-version</STRONG> <BR>
        &nbsp;输出java的版本信息，比如jdk版本、vendor、model。<BR>
        <STRONG>-version:release</STRONG> <BR>
        &nbsp;指定class或者jar运行时需要的jdk版本信息；若指定版本未找到，则以能找到的系统默认jdk版本执行；一般情况下，对于jar文件，可以在manifest文件中指定需要的版本信息，而不是在命令行。<BR>
        &nbsp;release中可以指定单个版本，也可以指定一个列表，中间用空格隔开，且支持复杂组合，比如：<BR>
        &nbsp;-version:"1.5.0_04 
        1.5*&amp;1.5.1_02+"<BR>
      &nbsp;指定class或者jar需要jdk版本为1.5.0_04或者是1.5系列中比1.5.1_02更高的所有版本。</P>
      <P><STRONG>-showversion</STRONG> <BR>
        &nbsp;输出java版本信息（与-version相同）之后，继续输出java的标准参数列表及其描述。<BR>
        &nbsp;<BR>
        <STRONG>-? <BR>
        -help</STRONG> <BR>
        &nbsp;输出java标准参数列表及其描述。<BR>
        <BR>
        <STRONG>-X</STRONG> <BR>
      &nbsp;输出非标准的参数列表及其描述。</P>
      <P>以上的这些参数我们经常会在很多情况下用到多个的组合，比如我们在用JProfiler进行跟踪监控时，需要在被监控java启动参数中加上如下配置：<BR>
        -agentlib:jprofilerti=port=8849&nbsp; 
        -Xbootclasspath/a:/usr/local/jprofiler5/bin/agent.jar<BR>
        其中就用到两个-agentlib和-X参数，bootclasspath参数的详细信息将会在非标准参数中详细说明。</P>
      <BR>
      <SPAN 
style="COLOR: red">http://blog.csdn.net/sfdev/archive/2008/01/24/2063464.aspx</SPAN><BR>
      <BR>
      <P>非标准参数又称为扩展参数，其列表如下：<BR>
        <STRONG>-Xint</STRONG><BR>
        &nbsp;设置jvm以解释模式运行，所有的字节码将被直接执行，而不会编译成本地码。<BR>
        &nbsp;<BR>
        <STRONG>-Xbatch</STRONG><BR>
        &nbsp;关闭后台代码编译，强制在前台编译，编译完成之后才能进行代码执行；<BR>
        &nbsp;默认情况下，jvm在后台进行编译，若没有编译完成，则前台运行代码时以解释模式运行。<BR>
        &nbsp;<BR>
        <STRONG>-Xbootclasspath:bootclasspath</STRONG><BR>
        &nbsp;让jvm从指定路径（可以是分号分隔的目录、jar、或者zip）中加载bootclass，用来替换jdk的rt.jar；若非必要，一般不会用到；<BR>
        <STRONG>-Xbootclasspath/a:path</STRONG><BR>
        &nbsp;将指定路径的所有文件追加到默认bootstrap路径中；<BR>
        <STRONG>-Xbootclasspath/p:path</STRONG><BR>
        &nbsp;让jvm优先于bootstrap默认路径加载指定路径的所有文件；<BR>
        &nbsp;<BR>
        <STRONG>-Xcheck:jni</STRONG><BR>
        &nbsp;对JNI函数进行附加check；此时jvm将校验传递给JNI函数参数的合法性，在本地代码中遇到非法数据时，jmv将报一个致命错误而终止；使用该参数后将造成性能下降，请慎用。<BR>
        &nbsp;<BR>
        <STRONG>-Xfuture</STRONG><BR>
        &nbsp;让jvm对类文件执行严格的格式检查（默认jvm不进行严格格式检查），以符合类文件格式规范，推荐开发人员使用该参数。<BR>
        &nbsp;<BR>
        <STRONG>-Xnoclassgc</STRONG><BR>
        &nbsp;关闭针对class的gc功能；因为其阻止内存回收，所以可能会导致OutOfMemoryError错误，慎用；<BR>
        &nbsp;<BR>
        <STRONG>-Xincgc</STRONG><BR>
        &nbsp;开启增量gc（默认为关闭）；这有助于减少长时间GC时应用程序出现的停顿；但由于可能和应用程序并发执行，所以会降低CPU对应用的处理能力。<BR>
        &nbsp;<BR>
        <STRONG>-Xloggc:file</STRONG><BR>
        &nbsp;与-verbose:gc功能类似，只是将每次GC事件的相关情况记录到一个文件中，文件的位置最好在本地，以避免网络的潜在问题。<BR>
        &nbsp;若与verbose命令同时出现在命令行中，则以-Xloggc为准。<BR>
        &nbsp;<BR>
        <STRONG>-Xmsn<BR>
        </STRONG>&nbsp;指定jvm堆的初始大小，默认为物理内存的1/64，最小为1M；可以指定单位，比如k、m，若不指定，则默认为字节。<BR>
        &nbsp;<BR>
        <STRONG>-Xmxn</STRONG><BR>
        &nbsp;指定jvm堆的最大值，默认为物理内存的1/4或者1G，最小为2M；单位与-Xms一致。<BR>
        &nbsp;<BR>
        <STRONG>-Xprof</STRONG><BR>
        &nbsp;跟踪正运行的程序，并将跟踪数据在标准输出输出；适合于开发环境调试。<BR>
        &nbsp;<BR>
        <STRONG>-Xrs</STRONG><BR>
        &nbsp;减少jvm对操作系统信号（signals）的使用，该参数从1.3.1开始有效；<BR>
        &nbsp;从jdk1.3.0开始，jvm允许程序在关闭之前还可以执行一些代码（比如关闭数据库的连接池），即使jvm被突然终止；<BR>
        &nbsp;jvm关闭工具通过监控控制台的相关事件而满足以上的功能；更确切的说，通知在关闭工具执行之前，先注册控制台的控制handler，然后对CTRL_C_EVENT, 
        CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and 
        CTRL_SHUTDOWN_EVENT这几类事件直接返回true。<BR>
        &nbsp;但如果jvm以服务的形式在后台运行（比如servlet引擎），他能接收CTRL_LOGOFF_EVENT事件，但此时并不需要初始化关闭程序；为了避免类似冲突的再次出现，从jdk1.3.1开始提供-Xrs参数；当此参数被设置之后，jvm将不接收控制台的控制handler，也就是说他不监控和处理CTRL_C_EVENT, 
        CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, or 
        CTRL_SHUTDOWN_EVENT事件。<BR>
        &nbsp;<BR>
        <STRONG>-Xssn<BR>
      </STRONG>&nbsp;设置单个线程栈的大小，一般默认为512k。&nbsp;</P>
      <P>上面这些参数中，比如<STRONG>-Xmsn、-Xmxn……</STRONG>都是我们性能优化中很重要的参数；<BR>
        <STRONG>-Xprof、-Xloggc:file</STRONG>等都是在没有专业跟踪工具情况下排错的好手；<BR>
        在上一小节中提到的关于JProfiler的配置中就使用到了<STRONG>-Xbootclasspath/a:path</STRONG>；</P>
      <BR>
      <A 
style="COLOR: red" 
href="http://blog.csdn.net/sfdev/archive/2008/01/24/2063928.aspx">http://blog.csdn.net/sfdev/archive/2008/01/24/2063928.aspx</A><BR>
      <BR>
      前面我们提到用-XX作为前缀的参数列表在jvm中可能是不健壮的，SUN也不推荐使用，后续可能会在没有通知的情况下就直接取消了；但是由于这些参数中的确有很多是对我们很有用的，比如我们经常会见到的-XX:PermSize、-XX:MaxPermSize等等；
      <P>下面我们将就Java HotSpot VM中<STRONG><FONT 
color=#ff0000>-XX:</FONT></STRONG>的可配置参数列表进行描述；<BR>
        这些参数可以被松散的聚合成三类：<BR>
        <STRONG>行为参数</STRONG>（Behavioral 
        Options）：用于改变jvm的一些基础行为；<BR>
        <STRONG>性能调优</STRONG>（Performance 
        Tuning）：用于jvm的性能调优；<BR>
        <STRONG>调试参数</STRONG>（Debugging 
        Options）：一般用于打开跟踪、打印、输出等jvm参数，用于显示jvm更加详细的信息；</P>
      <P>由于sun官方文档中对各参数的描述也都非常少（大多只有一句话），而且大多涉及OS层面的东西，很难描述清楚，所以以下是挑选了一些我们开发中可能会用得比较多的配置项，若需要查看所有参数列表，可以点击<A 
href="http://java.sun.com/docs/hotspot/VMOptions.html" dragover="true">HotSpot 
        VM Specific Options</A>.查看原文；</P>
      <P>首先来介绍<STRONG>行为参数</STRONG>：<BR>
        <BR>
      
      <TABLE height=238 cellSpacing=1 cellPadding=1 width=800 align=left summary="" 
border=1>
        <TBODY>
          <TR>
            <TD>参数及其默认值</TD>
            <TD>描述</TD>
          </TR>
          <TR>
            <TD>-XX:-DisableExplicitGC</TD>
            <TD>禁止调用System.gc()；但jvm的gc仍然有效</TD>
          </TR>
          <TR>
            <TD>-XX:+MaxFDLimit</TD>
            <TD>最大化文件描述符的数量限制</TD>
          </TR>
          <TR>
            <TD>-XX:+ScavengeBeforeFullGC</TD>
            <TD>新生代GC优先于Full GC执行</TD>
          </TR>
          <TR>
            <TD>-XX:+UseGCOverheadLimit</TD>
            <TD>在抛出OOM之前限制jvm耗费在GC上的时间比例</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:-UseConcMarkSweepGC</STRONG></TD>
            <TD><STRONG>对老生代采用并发标记交换算法进行GC</STRONG></TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:-UseParallelGC</STRONG></TD>
            <TD><STRONG>启用并行GC</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:-UseParallelOldGC</TD>
            <TD>对Full GC启用并行，当-XX:-UseParallelGC启用时该项自动启用</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:-UseSerialGC</STRONG></TD>
            <TD><STRONG>启用串行GC</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:+UseThreadPriorities</TD>
            <TD>启用本地线程优先级</TD>
          </TR>
        </TBODY>
      </TABLE>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      <BR>
      上面表格中黑体的三个参数代表着jvm中GC执行的三种方式，即<STRONG>串行、并行、并发</STRONG>；<BR>
      串行<STRONG>（SerialGC）</STRONG>是jvm的默认GC方式，一般适用于小型应用和单处理器，算法比较简单，GC效率也较高，但可能会给应用带来停顿；<BR>
      并行<STRONG>（ParallelGC）</STRONG>是指GC运行时，对应用程序运行没有影响，GC和app两者的线程在并发执行，这样可以最大限度不影响app的运行；<BR>
      并发<STRONG>（ConcMarkSweepGC）</STRONG>是指多个线程并发执行GC，一般适用于多处理器系统中，可以提高GC的效率，但算法复杂，系统消耗较大；
      </P>
      <P><STRONG><BR>
        性能调优</STRONG>参数列表：<BR>
      </P>
      <P>
      
      <TABLE height=272 cellSpacing=1 cellPadding=1 width=800 align=left summary="" 
border=1>
        <TBODY>
          <TR>
            <TD>参数及其默认值</TD>
            <TD>描述</TD>
          </TR>
          <TR>
            <TD>-XX:LargePageSizeInBytes=4m</TD>
            <TD>设置用于Java堆的大页面尺寸</TD>
          </TR>
          <TR>
            <TD>-XX:MaxHeapFreeRatio=70</TD>
            <TD>GC后java堆中空闲量占的最大比例</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:MaxNewSize=size</STRONG></TD>
            <TD><STRONG>新生成对象能占用内存的最大值</STRONG></TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:MaxPermSize=64m</STRONG></TD>
            <TD><STRONG>老生代对象能占用内存的最大值</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:MinHeapFreeRatio=40</TD>
            <TD>GC后java堆中空闲量占的最小比例</TD>
          </TR>
          <TR>
            <TD>-XX:NewRatio=2</TD>
            <TD>新生代内存容量与老生代内存容量的比例</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:NewSize=2.125m</STRONG></TD>
            <TD><STRONG>新生代对象生成时占用内存的默认值</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:ReservedCodeCacheSize=32m</TD>
            <TD>保留代码占用的内存容量</TD>
          </TR>
          <TR>
            <TD>-XX:ThreadStackSize=512</TD>
            <TD>设置线程栈大小，若为0则使用系统默认值</TD>
          </TR>
          <TR>
            <TD>-XX:+UseLargePages</TD>
            <TD>使用大页面内存</TD>
          </TR>
        </TBODY>
      </TABLE>
      </P>
      <P><BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
      </P>
      <P>我们在日常性能调优中基本上都会用到以上黑体的这几个属性；&nbsp;<BR>
        <BR>
      </P>
      <P><STRONG>调试参数</STRONG>列表：</P>
      <P>
      
      <TABLE style="WIDTH: 800px; HEIGHT: 426px" height=426 cellSpacing=1 
cellPadding=1 width=800 align=left summary="" border=1>
        <TBODY>
          <TR>
            <TD>参数及其默认值</TD>
            <TD>描述</TD>
          </TR>
          <TR>
            <TD>-XX:-CITime</TD>
            <TD>打印消耗在JIT编译的时间</TD>
          </TR>
          <TR>
            <TD>-XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log</TD>
            <TD>保存错误日志或者数据到文件中</TD>
          </TR>
          <TR>
            <TD>-XX:-ExtendedDTraceProbes</TD>
            <TD>开启solaris特有的dtrace探针</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</STRONG></TD>
            <TD><STRONG>指定导出堆信息时的路径或文件名</STRONG></TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:-HeapDumpOnOutOfMemoryError</STRONG></TD>
            <TD><STRONG>当首次遭遇OOM时导出此时堆中相关信息</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:OnError="&lt;cmd args&gt;;&lt;cmd args&gt;"</TD>
            <TD>出现致命ERROR之后运行自定义命令</TD>
          </TR>
          <TR>
            <TD>-XX:OnOutOfMemoryError="&lt;cmd args&gt;;&lt;cmd args&gt;"</TD>
            <TD>当首次遭遇OOM时执行自定义命令</TD>
          </TR>
          <TR>
            <TD>-XX:-PrintClassHistogram</TD>
            <TD>遇到Ctrl-Break后打印类实例的柱状信息，与jmap -histo功能相同</TD>
          </TR>
          <TR>
            <TD><STRONG>-XX:-PrintConcurrentLocks</STRONG></TD>
            <TD><STRONG>遇到Ctrl-Break后打印并发锁的相关信息，与jstack -l功能相同</STRONG></TD>
          </TR>
          <TR>
            <TD>-XX:-PrintCommandLineFlags</TD>
            <TD>打印在命令行中出现过的标记</TD>
          </TR>
          <TR>
            <TD>-XX:-PrintCompilation</TD>
            <TD>当一个方法被编译时打印相关信息</TD>
          </TR>
          <TR>
            <TD>-XX:-PrintGC</TD>
            <TD>每次GC时打印相关信息</TD>
          </TR>
          <TR>
            <TD>-XX:-PrintGC Details</TD>
            <TD>每次GC时打印详细信息</TD>
          </TR>
          <TR>
            <TD>-XX:-PrintGCTimeStamps</TD>
            <TD>打印每次GC的时间戳</TD>
          </TR>
          <TR>
            <TD>-XX:-TraceClassLoading</TD>
            <TD>跟踪类的加载信息</TD>
          </TR>
          <TR>
            <TD>-XX:-TraceClassLoadingPreorder</TD>
            <TD>跟踪被引用到的所有类的加载信息</TD>
          </TR>
          <TR>
            <TD>-XX:-TraceClassResolution</TD>
            <TD>跟踪常量池</TD>
          </TR>
          <TR>
            <TD>-XX:-TraceClassUnloading</TD>
            <TD>跟踪类的卸载信息</TD>
          </TR>
          <TR>
            <TD>-XX:-TraceLoaderConstraints</TD>
            <TD>跟踪类加载器约束的相关信息</TD>
          </TR>
        </TBODY>
      </TABLE>
      </P>
      <P><BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        <BR>
        当系统出现问题的时候，又不能使用外部跟踪工具（比如JProfiler……）的情况下，以上的这些参数就会发挥重大作用了，比如dump堆信息、打印并发锁……</P>
      <BR>
    </FONT><!--EndFragment--></DIV>
  </DIV>
</FORM>
</BODY>
</HTML>