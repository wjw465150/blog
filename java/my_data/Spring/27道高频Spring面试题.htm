<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>27道高频Spring面试题</title>
<meta name="GENERATOR" content="WinCHM">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style>
html,body { 
	/* Default Font */
	font-family: Arial, Helvetica, sans-serif;
	font-size: 11pt;
}
</style>

</head>

<body>
<H1 
style='FONT-SIZE: 24px; FONT-FAMILY: "Helvetica Neue", Helvetica, Tahoma, Arial, STXihei, "Microsoft YaHei", 微软雅黑, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; TEXT-TRANSFORM: none; FONT-WEIGHT: normal; COLOR: rgb(51,51,51); FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; MARGIN: 0px 0px 5px; LETTER-SPACING: normal; LINE-HEIGHT: 1.5em; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; text-rendering: optimizelegibility'>27 
道高频 Spring 面试题，你能答对几个？</H1>
<DIV class=article_meta 
style='FONT-SIZE: 14px; FONT-FAMILY: "Helvetica Neue", Helvetica, Tahoma, Arial, STXihei, "Microsoft YaHei", 微软雅黑, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; BORDER-BOTTOM: rgb(211,211,211) 1px dashed; TEXT-TRANSFORM: none; FONT-WEIGHT: 400; COLOR: rgb(153,153,153); PADDING-BOTTOM: 8px; FONT-STYLE: normal; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial'>
<DIV style="MARGIN-BOTTOM: 5px"><SPAN class=timestamp 
style="MARGIN-RIGHT: 5px">时间&nbsp;2019-07-25 
09:29:31<SPAN>&nbsp;</SPAN></SPAN><SPAN class=from style="MARGIN-RIGHT: 5px"><I 
class=icon-globe 
style="TEXT-DECORATION: ; HEIGHT: auto; FONT-FAMILY: FontAwesome; WIDTH: auto; VERTICAL-ALIGN: baseline; BACKGROUND-IMAGE: none; MARGIN-TOP: 0px; BACKGROUND-REPEAT: repeat; BACKGROUND-POSITION: 0px 0px; FONT-WEIGHT: normal; FONT-STYLE: normal; DISPLAY: inline; LINE-HEIGHT: normal; MARGIN-RIGHT: 0px; -webkit-font-smoothing: antialiased"></I><SPAN>&nbsp;</SPAN>公众账号</SPAN></DIV>
<DIV class=source><I 
style="FLOAT: left; FONT-STYLE: normal">原文</I>&nbsp;<SPAN>&nbsp;</SPAN><A 
class="cut cut70" 
style="OVERFLOW: hidden; TEXT-DECORATION: none; MAX-WIDTH: 69%; WHITE-SPACE: nowrap; TEXT-OVERFLOW: ellipsis; WORD-BREAK: keep-all; COLOR: rgb(51,51,51); OUTLINE-WIDTH: 0px; OUTLINE-STYLE: none; DISPLAY: inline-block; OUTLINE-COLOR: invert; transition: all 0.25s ease 0s" 
href="https://mp.weixin.qq.com/s/bOXZ7Tbat3QNImubXfhINA?utm_source=tuicool&amp;utm_medium=referral">https://mp.weixin.qq.com/s/bOXZ7Tbat3QNImubXfhINA</A></DIV>
<DIV><SPAN style="MARGIN-RIGHT: 5px">主题</SPAN><SPAN>&nbsp;</SPAN><A 
style="TEXT-DECORATION: none; COLOR: rgb(51,51,51); OUTLINE-WIDTH: 0px; OUTLINE-STYLE: none; OUTLINE-COLOR: invert; transition: all 0.25s ease 0s" 
href="https://www.tuicool.com/topics/11070001" target=_blank><SPAN 
class=new-label 
style="FONT-SIZE: 0.9em; TEXT-DECORATION: none; VERTICAL-ALIGN: baseline; WHITE-SPACE: nowrap; COLOR: rgb(120,120,120); PADDING-BOTTOM: 2px; PADDING-TOP: 2px; PADDING-LEFT: 4px; DISPLAY: inline-block; LINE-HEIGHT: 16px; PADDING-RIGHT: 4px; BACKGROUND-COLOR: rgb(242,242,242); MARGIN-RIGHT: 5px">Spring</SPAN></A></DIV></DIV>
<DIV id=nei class=article_body 
style='FONT-SIZE: 16px; MARGIN-BOTTOM: 0px; FONT-FAMILY: "Helvetica Neue", Helvetica, Tahoma, Arial, STXihei, "Microsoft YaHei", 微软雅黑, sans-serif; WHITE-SPACE: normal; WORD-SPACING: 0px; OVERFLOW-X: hidden; TEXT-TRANSFORM: none; WORD-BREAK: break-all; FONT-WEIGHT: 400; COLOR: rgb(51,51,51); PADDING-BOTTOM: 25px; FONT-STYLE: normal; PADDING-TOP: 20px; PADDING-LEFT: 5px; MIN-HEIGHT: 340px; ORPHANS: 2; WIDOWS: 2; LETTER-SPACING: normal; LINE-HEIGHT: 1.7em; PADDING-RIGHT: 5px; TEXT-INDENT: 0px; font-variant-ligatures: normal; font-variant-caps: normal; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; overflow-wrap: break-word'>
<DIV style="FONT-SIZE: 16px; LINE-HEIGHT: 1.7em">
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em"><SPAN>本文节选自<SPAN>&nbsp;</SPAN><STRONG 
style="FONT-WEIGHT: bold; TEXT-INDENT: 0px">《Spring 
5核心原理与30个类手写实战》</STRONG><SPAN>&nbsp;</SPAN>一书，谭勇德（Tom） 
著，电子工业出版社出版。本书基于编程开发实践，不仅深度解析Spring 
5的原理与新特性，更从环境准备、顶层结构设计、数据访问等方面一步步地推导出Spring的设计原理。在每个知识点上，均以大量的经典代码案例辅助讲解，使理论紧密联系实际。<SPAN>&nbsp;</SPAN></SPAN><SPAN>最后手写30个类，以体会Spring作者的创作过程，让每一位读者学以致用。</SPAN></P>
<P 
style="FONT-SIZE: 16px; TEXT-ALIGN: center; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">&nbsp;</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">1、什么是Spring框架，Spring框架有哪些主要模块</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring框架是一个为Java应用程序开发提供综合、广泛的基础性支持的Java平台。 
Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。 
Spring框架本身也是按照设计模式精心打造的，这使得我们可以在开发环境中安心地集成Spring框架，不必担心Spring是如何在后台工作的。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">2、使用Spring框架能带来哪些好处</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">下面列举了一些使用Spring框架带来的主要好处。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）Dependency 
Injection（DI）使得构造器和JavaBean properties文件中的依赖关系一目了然。 
（2）与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来使用IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。 
（3）Spring并没有闭门造车，Spring利用了已有的技术，比如ORM框架、logging框架、J2EE、Quartz和JDK 
Timer，以及其他视图技术。 （4）Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者只需选用需要的模块即可。 
（5）要测试一个用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便地利用依赖注入来写入测试数据。 
（6）Spring的Web框架也是一个精心设计的Web 
MVC框架，为开发者在Web框架的选择上提供了一个除主流框架（比如Struts）和过度设计的、不流行Web框架以外的选择。 
（7）Spring提供了一个便捷的事务管理接口，适用于小型的本地事务处理（比如在单DB的环境下）和复杂的共同事务处理（比如利用JTA的复杂DB环境）。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">3、什么是控制反转（IoC），什么是依赖注入</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）控制反转是应用于软件工程领域的，在运行时被装配器对象用来绑定耦合对象的一种编程技巧，对象之间的耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。绑定的过程是通过“依赖注入”实现的。 
（2）控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在实际工作中起到了有效的作用。 
（3）依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件呢？</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">4、在Java中依赖注入有哪些方式</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）构造器注入。 
（2）Setter方法注入。 （3）接口注入。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">5、BeanFactory和ApplicationContext有什么区别</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">BeanFactory可以理解为含有Bean集合的工厂类。BeanFactory 
包含了Bean的定义，以便在接收到客户端请求时将对应的Bean实例化。 
BeanFactory还能在实例化对象时生成协作类之间的关系。此举将Bean自身从Bean客户端的配置中解放出来。BeanFactory还包含Bean生命周期的控制，调用客户端的初始化方法（Initialization 
Method）和销毁方法（Destruction Method）。 
从表面上看，ApplicationContext如同BeanFactory一样具有Bean定义、Bean关联关系的设置及根据请求分发Bean的功能。但ApplicationContext在此基础上还提供了其他功能。 
（1）提供了支持国际化的文本消息。 （2）统一的资源文件读取方式。 （3）已在监听器中注册的Bean的事件。 以下是三种较常见的 
ApplicationContext 实现方式。 
（1）ClassPathXmlApplicationContext：从ClassPath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（2）FileSystemXmlApplicationContext 
：由文件系统中的XML配置文件读取上下文。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（3）XmlWebApplicationContext：由Web应用的XML文件读取上下文。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">6、Spring提供几种配置方式来设置元数据</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring提供以下三种配置方式来设置元数据：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）基于XML的配置。 
（2）基于注解的配置。 （3）基于Java的配置。</P>
<H3 
style="FONT-SIZE: 18px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.6em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">7、如何使用XML配置方式配置Spring</H3>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在Spring框架中，依赖和服务需要专门的配置文件实现，一般用XML格式的配置文件。这些配置文件的格式采用公共的模板，由一系列的Bean定义和专门的应用配置选项组成。 
Spring 
XML配置的主要目的是使所有的Spring组件都可以用XML文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明配置方式或基于Java 
Class的配置方式）。 
Spring的XML配置方式是使用被Spring命名空间所支持的一系列的XML标签来实现的。Spring主要的命名空间有context、beans、jdbc、tx、aop、mvc和aso。例如：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">下面这个web.xml仅配置了DispatcherServlet，最简单的配置便能满足应用程序配置运行时组件的需求。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">8、Spring提供哪些配置形式</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为Bean定义的资源。被@Configuration声明的类可以通过在同一个类内部调用@bean方法来设置嵌入Bean的依赖关系。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">最简单的@Configuration 
声明类请参考下面的代码：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">与上面的@Beans配置文件相同的XML配置文件如下：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">上述配置方式的实例化方式如下：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">要使用组件扫描，仅需用@Configuration进行注解即可：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在上面的例子中，com.gupaoedu包首先会被扫描到，然后在容器内查找被@Component 
声明的类，找到后将这些类按照Spring Bean定义进行注册。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">如果你要在Web应用开发中选用上述配置方式，需要用AnnotationConfigWebApplicationContext类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring 
MVC的DispatcherServlet。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">例如：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">9、怎样用注解的方式配置Spring</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring在2.5版本以后开始支持用注解的方式配置依赖注入。可以用注解的方式来替代XML方式的Bean描述，可以将Bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前处理，所以后者会覆盖前者对于同一个属性的处理结果。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">注解装配在Spring中是默认关闭的，需要在Spring文件中进行配置才能使用基于注解的装配模式。如果你想要在应用程序中使用注解的方式，请参考如下配置：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">下面是几种比较重要的注解类型。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）@Required：该注解应用于设值方法。 
（2）@Autowired：该注解应用于设值方法、非设值方法、构造方法和变量。 
（3）@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定Bean自动装配的歧义。 （4）JSR-250 
Annotations：Spring支持基于JSR-250 注解的注解，即@Resource、@PostConstruct和@PreDestroy。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">10、请解释Spring 
Bean的生命周期</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring 
Bean的生命周期简单易懂。在一个Bean实例被初始化时，需要执行一系列初始化操作以使其达到可用的状态。同样，当一个Bean不再被调用时需要进行相关的析构操作，并从Bean容器中移除。 
Spring Bean Factory 负责管理在Spring容器中被创建的Bean的生命周期。Bean的生命周期由两组回调方法组成。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）初始化之后调用的回调方法。 
（2）销毁之前调用的回调方法。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring提供了以下4种方式来管理Bean的生命周期事件：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）InitializingBean和DisposableBean回调接口。 
（2）针对特殊行为的其他Aware接口。 （3）Bean配置文件中的customInit()方法和customDestroy()方法。 
（4）@PostConstruct和@PreDestroy注解方式。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">使用customInit()和 
customDestroy()方法管理Bean生命周期的代码样例如下：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">11、Spring 
Bean作用域的区别是什么</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring容器中的Bean可以分为5个作用域。所有作用域的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）singleton：这种Bean作用域是默认的，这种作用域确保不管接收到多少个请求，每个容器中只有一个Bean实例，单例模式由Bean 
Factory自身来维护。 （2）prototype：prototype作用域与singleton作用域相反，为每一个Bean请求提供一个实例。 
（3）request：在请求Bean作用域内为每一个来自客户端的网络请求创建一个实例，在请求完成以后，Bean会失效并被垃圾回收器回收。 
（4）Session：与request作用域类似，确保每个Session中有一个Bean实例，在Session过期后，Bean会随之失效。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（5）global-session：global-session和Portlet应用相关。当应用部署在Portlet容器中时，它包含很多Portlet。如果想让所有的Portlet共用全局存储变量，那么这个全局存储变量需要存储在global-session中。全局作用域与Servlet中的Session作用域效果相同。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">12、什么是Spring 
Inner Bean</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在Spring中，无论何时，当Bean仅被调用了一个属性时，一个明智的做法是将这个Bean声明为内部Bean。内部Bean可以用setter注入“属性”和用构造方法注入“构造参数”的方式来实现。 
比如，在应用程序中一个Customer类引用了一个Person类，我们要创建一个Person类的实例，然后在Customer内部使用。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">内部Bean的声明方式如下：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">13、Spring中的单例Bean是线程安全的吗</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring并没有对单例Bean进行任何多线程的封装处理。关于单例Bean的线程安全和并发问题需要开发者自行解决。但实际上，大部分Spring 
Bean并没有可变的状态（比如Serview类和DAO类），所以在某种程度上，Spring的单例Bean是线程安全的。如果你的Bean有多种状态（比如View 
Model对象），就需要自行保证线程安全。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">最容易的解决办法就是将多态Bean的作用域由“singleton”变更为“prototype”。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">14、请举例说明如何在Spring中注入一个Java集合</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring提供了以下4种集合类的配置元素：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）&lt;list&gt;标签用来装配可重复的list值。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（2）&lt;set&gt;标签用来装配没有重复的set值。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（3）&lt;map&gt;标签用来注入键和值，可以为任何类型的键值对。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（4）&lt;props&gt;标签支持注入键和值都是字符串类型的键值对。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">下面看一个具体的例子：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">15、如何向Spring 
Bean中注入java.util.Properties</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">第一种方法是使用如下代码所示的标签：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">也可用“util:”命名空间从Properties文件中创建一个Properties 
Bean，然后利用setter方法注入Bean的引用。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">16、请解释Spring 
Bean的自动装配</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在Spring框架中，在配置文件中设定Bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系Bean之间的关联关系。这意味着Spring可以通过向BeanFactory中注入的方式自动搞定Bean之间的依赖关系。自动装配可以设置在每个Bean上，也可以设置在特定的Bean上。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">下面的XML配置文件表明了如何根据名称将一个Bean设置为自动装配模式：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">除了Bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的Bean。在使用@Autowired注解之前需要按照如下的配置方式在Spring配置文件中进行配置：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 
达到相同的效果：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">配置好以后就可以使用@Autowired来标注了：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">17、自动装配有哪些局限性</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">自动装配有如下局限性。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">• 
重写：你仍然需要使用&lt; property&gt;设置指明依赖，这意味着总要重写自动装配。 • 
原生数据类型：你不能自动装配简单的属性，如原生类型、字符串和类。 • 模糊特性：自动装配总是没有自定义装配精确，因此如果可能尽量使用自定义装配。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">18、请解释各种自动装配模式的区别</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在Spring中共有5种自动装配模式，让我们逐一分析。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）no：这是Spring的默认设置，在该设置下自动装配是关闭的，开发者需要自行在Bean定义中用标签明确地设置依赖关系。 
（2）byName：该模式可以根据Bean名称设置依赖关系。当向一个Bean中自动装配一个属性时，容器将根据Bean的名称自动在配置文件中查询一个匹配的Bean。如果找到就装配这个属性，如果没找到就报错。 
（3）byType：该模式可以根据Bean类型设置依赖关系。当向一个Bean中自动装配一个属性时，容器将根据Bean的类型自动在配置文件中查询一个匹配的Bean。如果找到就装配这个属性，如果没找到就报错。 
（4）constructor：和byType模式类似，但是仅适用于有与构造器相同参数类型的Bean，如果在容器中没有找到与构造器参数类型一致的Bean，那么将会抛出异常。 
（5）autodetect：该模式自动探测使用constructor自动装配或者byType自动装配。首先会尝试找合适的带参数的构造器，如果找到就是用构造器自动装配，如果在Bean内部没有找到相应的构造器或者构造器是无参构造器，容器就会自动选择byType模式。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">19、请举例解释@Required注解</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在产品级别的应用中，IoC容器可能声明了数十万个Bean，Bean与Bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过设置“dependency-check”来解决这个问题。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在应用程序的生命周期中，你可能不大愿意花时间验证所有Bean的属性是否按照上下文文件正确配置，或者你宁可验证某个Bean的特定属性是否被正确设置。即使用“dependency-check”属性也不能很好地解决这个问题，在这种情况下需要使用@Required 
注解。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">可用如下的方式来标明Bean的设值方法：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">RequiredAnnotationBeanPostProcessor是Spring中的后置处理器，用来验证被@Required 
注解的Bean属性是否被正确设置了。在使用RequiredAnnotationBeanPostProcesso验证Bean属性之前，要在IoC容器中对其进行注册：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">但是如果没有属性被用@Required注解过，后置处理器会抛出一个BeanInitializationException异常。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">20、请举例说明@Qualifier注解</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">@Qualifier注解意味着可以在被标注Bean的字段上自动装配。@Qualifier注解可以用来取消Spring不能取消的Bean应用。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">21、构造方法注入和设值注入有什么区别</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">请注意以下明显的区别：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）设值注入支持大部分依赖注入，如果我们仅需要注入int、string和long型的变量，不要用设值方法注入。对于基本类型，如果没有注入，可以为基本类型设置默认值。构造方法注入不支持大部分依赖注入，因为在调用构造方法时必须传入正确的构造参数，否则会报错。 
（2）设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入和设值注入，那么构造方法将不能覆盖设值注入的值。很明显，因为构造方法只在对象被创建时被调用。 
（3）在使用设值注入时还不能保证某种依赖是否已经被注入，也就是说，这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 
（4）在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出ObjectCurrentlyInCreationException异常，因为在对象B被创建之前对象A是不能被创建的，反之亦然。Spring用设值注入解决了循环依赖问题，因为对象的设值方法是在对象被创建之前被调用的。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">22、Spring中有哪些不同类型的事件</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring的ApplicationContext 
提供了支持事件和代码中监听器的功能。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">我们可以创建Bean来监听在ApplicationContext 
中发布的事件。对于ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个Bean实现了ApplicationListener接口，当一个ApplicationEvent 
被发布以后，Bean会自动被通知。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring 
提供了以下5种标准的事件。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 
接口中的refresh()方法时被触发。 
（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始或重新开始容器时触发该事件。 
（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 
（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。 
（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个HTTP请求（Request）结束时触发该事件。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">除了上面介绍的事件，还可以通过扩展ApplicationEvent类来自定义事件：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">为了监听这个事件，还需要创建一个监听器：</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">之后通过ApplicationContext接口的publishEvent()方法来发布自定义事件：</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">23、FileSystemResource和ClassPathResource有什么区别</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">在FileSystemResource 
中需要给出spring-config.xml文件在项目中的相对路径或者绝对路径。在ClassPathResource中Spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 
文件放在ClassPath下。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">如果将spring-config.xml保存在了src目录下，只需给出配置文件的名称即可，因为src是默认的路径。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">24、Spring中用到了哪些设计模式</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring中使用了大量的设计模式，下面列举了一些比较有代表性的设计模式。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">（1）代理模式：在AOP和remoting中被用得比较多。 
（2）单例模式：在Spring配置文件中定义的Bean默认为单例模式。 
（3）模板模式：用来解决代码重复问题，比如RestTemplate、JmsTemplate、JpaTemplate。 
（4）委派模式：Spring提供了DispatcherServlet来对请求进行分发。 
（5）工厂模式：BeanFactory用来创建对象的实例，贯穿于BeanFactory和ApplicationContext接口。 
（6）代理模式：代理模式AOP思想的底层实现技术，Spring中采用JDK Proxy和CGLib类库。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">25、在Spring中如何更有效地使用JDBC</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">使用Spring 
JDBC可以使得资源管理及错误处理的代价减小。开发人员只需通过statements和queries语句从数据库中存取数据。Spring通过模板类能更有效地使用JDBC，也就是所谓的JdbcTemplate。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">26、请解释Spring中的IoC容器</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">Spring中的org.springframework.beans包和org.springframework.context包构成了Spring 
IoC容器的基础。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">BeanFactory接口提供了一个先进的配置机制，使得任何类型的对象的配置都成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理Message 
Resource的机制（用于国际化），以及事件传播及应用层的特别配置，比如针对Web应用的WebApplicationContext。</P>
<H4 
style="FONT-SIZE: 16px; FONT-FAMILY: inherit; FONT-WEIGHT: bold; COLOR: ; MARGIN: 0px 0px 0.5em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em; text-rendering: optimizelegibility">27、在Spring中可以注入null或空字符串吗</H4>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">完全可以。</P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em"><SPAN>留言交流不过瘾？</SPAN><SPAN>&nbsp;</SPAN><SPAN>添加微信：</SPAN><SPAN>&nbsp;</SPAN><SPAN><STRONG 
style="FONT-WEIGHT: bold; TEXT-INDENT: 0px">zyc_enjoy</STRONG></SPAN></P>
<P 
style="FONT-SIZE: 16px; MARGIN: 0px 0px 0.75em; LINE-HEIGHT: 1.7em; TEXT-INDENT: 1em">根据指引加入各种主题讨论群</P></DIV></DIV></body>
</html>
