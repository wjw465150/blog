<!-- saved from url=http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn -->
<script>
window.onerror = new Function("return(false);")
</script><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">

<HTML lang=zh-CN xml:lang="zh-CN" 
xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"><title>使用 StAX 解析 XML，第 1 部分: Streaming API for XML (StAX) 简介</title><LINK 
href="" rel=schema.DC><LINK 
href="favicon.ico" rel="SHORTCUT ICON"><LINK 
media=screen,print href="table.css" type=text/css 
rel=stylesheet>
<SCRIPT language=JavaScript src="dwcss14.js" 
type=text/javascript></SCRIPT>
<LINK href="/developerworks/css/ie6v14.css" type=text/css 
rel=stylesheet><NOSCRIPT><link rel="stylesheet" href="r1ss.css" type="text/css"/></NOSCRIPT><LINK 
href="main.css" type=text/css rel=stylesheet><LINK 
media=all href="screen.css" type=text/css 
rel=stylesheet><LINK media=print href="print.css" 
type=text/css rel=stylesheet>
<SCRIPT language=JavaScript src="detection.js" 
type=text/javascript></SCRIPT>
<LINK media=screen href="ie2_screen.css" 
type=text/css rel=stylesheet>
<SCRIPT language=JavaScript src="dropdown.js" 
type=text/javascript></SCRIPT>

<SCRIPT language=JavaScript src="grabtitle.js" 
type=text/javascript></SCRIPT>

<SCRIPT language=JavaScript src="emailfriend2.js" 
type=text/javascript></SCRIPT>
<!--START RESERVED FOR FUTURE USE INCLUDE FILES-->
<SCRIPT language=javascript src="ajax1.js" 
type=text/javascript></SCRIPT>

<SCRIPT language=javascript src="searchcount.js" 
type=text/javascript></SCRIPT>
<!--END RESERVED FOR FUTURE USE INCLUDE FILES-->
<SCRIPT language=JavaScript type=text/javascript>var emailAbstract = "Streaming API for XML (StAX) 是用 Java（TM）语言处理 XML 的最新标准。作为一种面向流的方法，无论从性能还是可用性上都优于其他方法，如 DOM 和 SAX。本系列分为 3 部分，本文是第 1 部分，简要介绍了 StAX 及其处理 XML 的基于指针的 API。"; </SCRIPT>
</HEAD>

<BODY><!--StartFragment--><!--MASTHEAD_BEGIN-->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top>
<TD class=bbg width=110><A href="http://www.ibm.com/cn/"><IMG border=0 alt=IBM? 
src="ibm-logo.gif" width=110 height=52></A></TD>
<TD class=bbg><IMG border=0 alt="" src="c.gif" width=1 
height=1></TD>
<TD class=mbbg align=right width=650>
<TABLE cellSpacing=0 cellPadding=0 align=right border=0>
<TBODY>
<TR class=cty-tou>
<TD class=upper-masthead-corner width=17 rowSpan=2><A href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><IMG border=0 
alt=跳转到主要内容 src="c.gif" width=1 height=1></A></TD>
<TD align=left>
<TABLE cellSpacing=0 cellPadding=0 align=left border=0>
<TBODY>
<TR>
<TD><SPAN class=spacer>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B class=country>中国</B><SPAN 
class=spacer>&nbsp;[</SPAN><A class=ur-link 
href="">选择</A><SPAN 
class=spacer>]</SPAN></TD>
<TD class=upper-masthead-divider width=29>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD align=left><A class=ur-link 
href="">使用条款</A></TD></TR></TBODY></TABLE></TD>
<TD width=40>&nbsp;</TD></TR>
<TR>
<TD class=cty-tou-border colSpan=2 height=1><IMG alt="" src="c.gif" 
width=1 height=1></TD></TR>
<TR>
<TD colSpan=3><IMG alt="" src="c.gif" width=1 
height=8></TD></TR>
<TR>
<TD>&nbsp;</TD>
<TD align=center colSpan=2>
<FORM id=form1 name=form1 
action=http://www-128.ibm.com/developerworks/search/searchResults.jsp 
method=get><INPUT type=hidden value=1 name=searchType><INPUT type=hidden 
value=dWChina name=searchSite><INPUT type=hidden value=zh name=pageLang><INPUT 
type=hidden value=UTF8 name=langEncoding>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD width=1><IMG alt="Select a scope:" src ="c.gif" 
width=1 height=1 ></TD>
<TD align=right><LABEL for=sq><SELECT class=input-scope id=sq 
name=searchScope><OPTION value=dW selected>dW 全部内容</OPTION><OPTION 
value=dW>-----------------</OPTION><OPTION value=aixunix>&nbsp;&nbsp;AIX and 
UNIX</OPTION><OPTION value=dmdd>&nbsp;&nbsp;Information management</OPTION><OPTION 
value=lotusdd>&nbsp;&nbsp;Lotus</OPTION><OPTION value=rdd>&nbsp;&nbsp;Rational</OPTION><OPTION 
value=tivolidd>&nbsp;&nbsp;Tivoli</OPTION><OPTION value=wsdd>&nbsp;&nbsp;WebSphere</OPTION><OPTION 
value=workplace>&nbsp;&nbsp;Workplace</OPTION><OPTION 
value=dW>-----------------</OPTION><OPTION value=gridZ>&nbsp;&nbsp;Grid 
computing</OPTION><OPTION value=javaZ>&nbsp;&nbsp;Java 技术</OPTION><OPTION 
value=linuxZ>&nbsp;&nbsp;Linux</OPTION><OPTION value=opensrcZ>&nbsp;&nbsp;Open 
source</OPTION><OPTION value=securityZ>&nbsp;&nbsp;Security</OPTION><OPTION 
value=webservZ>&nbsp;&nbsp;SOA &amp; Web services</OPTION><OPTION value=webarchZ>&nbsp;&nbsp;Web 
development</OPTION><OPTION value=xmlZ>&nbsp;&nbsp;XML</OPTION><OPTION 
value=dW>-----------------</OPTION><OPTION value=all>IBM 
全部内容</OPTION></SELECT></LABEL></TD>
<TD align=right width=1><IMG alt="Search for:" src 
="c.gif" width=1 height=1 >&nbsp;&nbsp;</TD>
<TD align=right><INPUT class=input id=q maxLength=100 size=15 name=query></TD>
<TD width=7>&nbsp;</TD>
<TD><LABEL for=q><INPUT type=image alt=搜索 
src="search.gif" value=搜索 name=Search></LABEL></TD>
<TD 
width=20>&nbsp;</TD></TR></TBODY></TABLE></FORM></TD></TR></TBODY></TABLE></TD></TR>
<TR>
<TD class=blbg colSpan=3>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD><SPAN class=spacer>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></TD>
<TD><A class=masthead-mainlink href="http://www.ibm.com/cn/">首页</A></TD>
<TD class=masthead-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=masthead-mainlink 
href="">产品</A></TD>
<TD class=masthead-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=masthead-mainlink 
href="">服务与解决方案</A></TD>
<TD class=masthead-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=masthead-mainlink 
href="">支持与下载</A></TD>
<TD class=masthead-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=masthead-mainlink 
href="">个性化服务</A></TD>
<TD><SPAN 
class=spacer>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><!--
<script src="pmh.js" language="JavaScript" type="text/javascript"></script>
--><!-- end masthead dw liquid --><!--MASTHEAD_END--><!-- CMA ID for this content is: 199624 -->
<TABLE id=v14-body-table cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top><!--LEFTNAV_BEGIN-->
<TD id=navigation width=150>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=left-nav-spacer><A class=left-nav-overview 
href="http://www.ibm.com/developerworks/cn/">&nbsp;</A></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=left-nav-overview colSpan=2><A class=left-nav-overview 
href="http://www.ibm.com/developerworks/cn/">developerWorks<BR>中国</A></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=left-nav colSpan=2><A class=left-nav 
href="http://www.ibm.com/developerworks/cn/views/xml/articles.jsp?view_by=search&amp;search_by=StAX+XML">本系列的更多信息:</A><BR><A 
class=left-nav-child 
href="http://www.ibm.com/developerworks/cn/views/xml/articles.jsp?view_by=search&amp;search_by=StAX+XML">使用 
StAX 解析 XML</A></TD></TR>
<TR>
<TD class=dw-left-nav-separator width=14><IMG alt="" src="c.gif" 
width=14 height=6></TD>
<TD class=dw-left-nav-separator width=136><IMG alt="" src="c.gif" 
width=136 height=6></TD></TR>
<TR>
<TD class=left-nav-highlight colSpan=2><A class=left-nav 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#">本文内容包括:</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#N10053">StAX 概述</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#N10065">基本原理</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#N100E4">基于指针的 API</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#N102E5">基于指针处理之外的其他技术</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#N10309">结束语</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#resources">参考资料 </A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#author">关于作者</A></TD></TR>
<TR class=left-nav-child-highlight>
<TD><IMG alt="" src="cl-bullet.gif" width=2 height=8></TD>
<TD><A class=left-nav-child href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#rate">对本文的评价</A></TD></TR>
<TR class=left-nav-last>
<TD width=14><IMG class=display-img alt="" src="c.gif" width=14 
height=1></TD>
<TD width=136><IMG class=display-img alt="" src="left-nav-corner.gif" 
width=136 
height=19></TD></TR></TBODY></TABLE><BR>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=related colSpan=2><B class=related>相关链接:</B></TD></TR>
<TR class=rlinks>
<TD><IMG alt="" src="rl-bullet.gif" width=2 height=8></TD>
<TD><A class=rlinks 
href="http://www.ibm.com/developerworks/cn/views/xml/articles.jsp">XML 
技术文档库</A></TD></TR>
<TR class=rlinks>
<TD><IMG alt="" src="rl-bullet.gif" width=2 height=8></TD>
<TD><A class=rlinks 
href="http://www.ibm.com/developerworks/cn/views/java/articles.jsp">Java 
technology 技术文档库</A></TD></TR><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- No content currently --><!--END RESERVED FOR FUTURE USE INCLUDE FILES-->
<TR>
<TD width=14><IMG class=display-img alt="" src="c.gif" width=14 
height=1></TD>
<TD width=136><IMG class=display-img alt="" src="c.gif" 
width=136 height=19></TD></TR></TBODY></TABLE><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- No content currently --><!--END RESERVED FOR FUTURE USE INCLUDE FILES--></TD><!--LEFTNAV_END-->
<TD width="100%">
<TABLE id=content-table cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top>
<TD width="100%">
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD><A name=main><IMG border=0 alt="skip to main content" 
src="c.gif" width=592 height=1></A></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top>
<TD width=10 height=18><IMG alt="" src="c.gif" width=10 
height=18></TD>
<TD width="100%"><IMG alt="" src="c.gif" width=1 height=6><BR><A 
class=bctl href="http://www.ibm.com/developerworks/cn/">developerWorks 
中国</A><SPAN class=bct>&nbsp;&nbsp;&gt;&nbsp;&nbsp;</SPAN><A class=bctl 
href="http://www.ibm.com/developerworks/cn/xml/">XML</A><SPAN 
class=bct>&nbsp;|&nbsp;</SPAN><A class=bctl 
href="http://www.ibm.com/developerworks/cn/java/">Java technology</A><SPAN 
class=bct>&nbsp;&nbsp;&gt;</SPAN><IMG alt="" src="c.gif" width=1 
height=1><BR>
<H1><SPAN style="COLOR: #999999">使用 StAX 解析 XML，第 1 部分: </SPAN>Streaming API for 
XML (StAX) 简介</H1>
<P id=subtitle><EM>探究其基于指针的 API，它把 XML 作为标记（或事件）流拉出</EM></P><IMG 
class=display-img alt="" src="c.gif" width=1 height=6></TD>
<TD class=no-print width=192><IMG alt=developerWorks src="dw.gif" 
width=192 
height=18></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top>
<TD width=10><IMG alt="" src="c.gif" width=10 height=1></TD>
<TD width="100%">
<TABLE class=no-print cellSpacing=0 cellPadding=0 width=160 align=right 
border=0>
<TBODY>
<TR>
<TD width=10><IMG alt="" src="c.gif" width=10 height=1></TD>
<TD>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=v14-header-1-small>文档选项</TD></TR></TBODY></TABLE>
<TABLE class=v14-gray-table-border cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=no-padding width=150>
<TABLE cellSpacing=0 cellPadding=0 width=143 border=0><IMG alt="" src="c.gif" 
width=8 height=1>
<FORM name=email 
action=https://www.ibm.com/developerworks/secure/email-it.jsp><INPUT type=hidden 
value="Streaming API for XML (StAX) 是用 Java（TM）语言处理 XML 的最新标准。作为一种面向流的方法，无论从性能还是可用性上都优于其他方法，如 DOM 和 SAX。本系列分为 3 部分，本文是第 1 部分，简要介绍了 StAX 及其处理 XML 的基于指针的 API。" 
name=body><INPUT type=hidden 
value="使用 StAX 解析 XML，第 1 部分: Streaming API for XML (StAX) 简介" 
name=subject><INPUT type=hidden value=cn name=lang>
<SCRIPT language=JavaScript type=text/javascript>
<!--
document.write('<tr valign="top"><td width="8"><img src="c.gif" width="8" height="1" alt=""/></td><td width="16"><img src="em.gif" height="16" width="16" vspace="3" alt="将此页作为电子邮件发送" /></td><td width="122"><p><a class="smallplainlink" href="javascript:document.email.submit();"><b>将此页作为电子邮件发送</b></a></p></td></tr>');
//-->
</SCRIPT>

<TBODY>
<TR vAlign=top>
<TD width=8><IMG alt="" src="c.gif" width=8 height=1></TD>
<TD width=16><IMG alt=将此页作为电子邮件发送 vspace=3 
src="em.gif" width=16 height=16></TD>
<TD width=122>
<P><A class=smallplainlink 
href="javascript_document.email.submit();"><B>将此页作为电子邮件发送</B></A></P></TD></TR><NOSCRIPT></NOSCRIPT></FORM>
<TR vAlign=top>
<TD width=8><IMG alt="" src="c.gif" width=8 height=1></TD>
<TD width=16><IMG border=0 alt="" vspace=3 
src="fw_bold.gif" width=16 height=16></TD>
<TD width=122>
<P><A class=smallplainlink 
href=""><B>讨论</B></A></P></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- 03/20/06 updated by gretchen --><BR>
<TABLE cellSpacing=0 cellPadding=0 width=150 border=0>
<TBODY>
<TR>
<TD class=v14-header-2-small>拓展 Tomcat 应用</TD></TR></TBODY></TABLE>
<TABLE class=v14-gray-table-border cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD class=no-padding width=150>
<TABLE cellSpacing=0 cellPadding=0 width=143 border=0>
<TBODY>
<TR vAlign=top>
<TD width=8><IMG alt="" src="c.gif" width=8 height=1></TD>
<TD><IMG border=0 alt="" vspace=3 src="fw_bold.gif" 
width=16 height=16></TD>
<TD width=125>
<P><A class=smallplainlink 
href="webserver.html_S_TACT=105AGX52&amp;S_CMP=simpleart">下载 
IBM 开源 J2EE 应用服务器 WAS CE 新版本 V1.1</A> 
</P></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><!--END RESERVED FOR FUTURE USE INCLUDE FILES--><BR></TD></TR></TBODY></TABLE>
<P>级别: 中级</P>
<P><A href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#author">Peter Nehrer</A> (<A 
href="mailto:pnehrer@ecliptical.ca%3Fsubject=Streaming%20API%20for%20XML%20(StAX)%20简介%26amp;cc=dwxed@us.ibm.com">pnehrer@ecliptical.ca</A>), 
自由撰稿人, Consultant<BR></P>
<P>2007 年 3 月 02 日</P>
<BLOCKQUOTE>Streaming API for XML (StAX) 是用 Java? 语言处理 XML 
的最新标准。作为一种面向流的方法，无论从性能还是可用性上都优于其他方法，如 DOM 和 SAX。本系列分为 3 部分，本文是第 1 部分，简要介绍了 StAX 
及其处理 XML 的基于指针的 API。</BLOCKQUOTE><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters --><!--END RESERVED FOR FUTURE USE INCLUDE FILES-->
<P><A name=N10053><SPAN class=atitle>StAX 概述</SPAN></A></P>
<P>从一开始，Java API for XML Processing (JAXP) 就提供了两种方法来处理 
XML：文档对象模型（DOM）方法是用标准的对象模型表示 XML 文档；Simple API for XML (SAX) 
方法使用应用程序提供的事件处理程序来处理 XML。JSR-173 提出了一种面向流的新方法：Streaming API for XML 
(StAX)。其最终版本于 2004 年 3 月发布，并成为了 JAXP 1.4（将包含在即将发布的 Java 6 中）的一部分。</P>
<P>如其名称所暗示的那样，StAX 把重点放在<I>流</I>上。实际上，StAX 与其他方法的区别就在于应用程序能够把 XML 作为一个事件流来处理。将 
XML 作为一组事件来处理的想法并不新颖（事实上 SAX 已经提出来了），但不同之处在于 StAX 
允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</P>
<P>StAX 实际上包括两套处理 XML 的 API，分别提供了不同程度的抽象。基于指针的 API 允许应用程序把 XML 
作为一个标记（或事件）流来处理；应用程序可以检查解析器的状态，获得解析的上一个标记的信息，然后再处理下一个标记，依此类推。这是一种低层 
API，尽管效率高，但是没有提供底层 XML 结构的抽象。较为高级的基于迭代器的 API 允许应用程序把 XML 
作为一系列事件对象来处理，每个对象和应用程序交换 XML 
结构的一部分。应用程序只需要确定解析事件的类型，将其转换成对应的具体类型，然后利用其方法获得属于该事件的信息。</P><BR>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD><IMG alt="" src="blue_rule.gif" width="100%" 
height=1><BR><IMG border=0 alt="" src="c.gif" width=8 
height=6></TD></TR></TBODY></TABLE>
<TABLE class=no-print cellSpacing=0 cellPadding=0 align=right>
<TBODY>
<TR align=right>
<TD><IMG alt="" src="c.gif" width="100%" height=4><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD vAlign=middle><IMG border=0 alt="" 
src="u_bold.gif" width=16 height=16><BR></TD>
<TD vAlign=top align=right><A class=fbox 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><B>回页首</B></A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR>
<P><A name=N10065><SPAN class=atitle>基本原理</SPAN></A></P>
<P>为了使用这两类 API，应用程序首先必须获得一个具体的 <CODE>XMLInputFactory</CODE>。根据传统的 JAXP 
风格，要用到抽象工厂模式；<CODE>XMLInputFactory</CODE> 类提供了静态的 <CODE>newInstance</CODE> 
方法，它负责定位和实例化具体的工厂。配置该实例可设置定制或者预先定义好的属性（其名称在类 XMLInputFactory 中定义）。最后，为了使用基于指针的 
API，应用程序还要通过调用某个 <CODE>createXMLStreamReader</CODE> 方法获得一个 
<CODE>XMLStreamReader</CODE>。如果要使用基于事件迭代器的 API，应用程序就要调用 
<CODE>createXMLEventReader</CODE> 方法获得一个 <CODE>XMLEventReader</CODE>（如清单 1 
所示）。</P><BR><A name=N1008E><B>清单 1. 获取和配置默认的 XMLInputFactory</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
// get the default factory instance
XMLInputFactory factory = XMLInputFactory.newInstance();
// configure it to create readers that coalesce adjacent character sections
factory.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);
XMLStreamReader r = factory.createXMLStreamReader(input);
// ...
</PRE></TD></TR></TBODY></TABLE><BR>
<P><CODE>XMLStreamReader</CODE> 和 <CODE>XMLEventReader</CODE> 都允许应用程序迭代底层的 XML 
流。两种方法的差别在于如何公开解析后的 XML InfoSet 信息片段。<CODE>XMLStreamReader</CODE> 
就像一个指针，指在刚刚解析过的 XML 
标记的后面，并提供了方法获得更多关于该标记的信息。这种方法节约内存，因为不用创建新的对象。但是，业务应用程序开发人员可能会发现 
<CODE>XMLEventReader</CODE> 更直观一些，因为它实际上就是一个标准的 Java 迭代器，将 XML 
变成了事件对象流。每个事件对象都封装了它所表示的特定 XML 结构固有的信息。本系列的第二部分将详细讨论这种基于事件迭代器的 API。</P>
<P>使用哪种风格的 API 取决于具体情况。和基于指针的 API 相比，基于事件迭代器的 API 
具有更多的面向对象特征。因此更便于应用于模块化的体系结构，因为当前的解析器状态反映在事件对象中，应用程序组件在处理事件的时候不需要访问解析器/读取器。此外，还可以使用 
<CODE>XMLInputFactory</CODE> 的 
<CODE>createXMLEventReader(XMLStreamReader)</CODE> 方法从 
<CODE>XMLStreamReader</CODE> 创建 <CODE>XMLEventReader</CODE>。</P>
<P>StAX 还定义了一种序列化器 API，Java 标准 XML 处理支持中一直缺少的一种特性。和解析一样，也包含两种风格的流式 API：处理标记的底层 
<CODE>XMLStreamWriter</CODE> 和处理事件对象的高层 
<CODE>XMLEventWriter</CODE>。<CODE>XMLStreamWriter</CODE> 提供了写入单个 XML 
记号（比如开始和关闭标记或者元素属性）的方法，不检查这些标记是否格式良好。另一方面，<CODE>XMLEventWriter</CODE> 
允许应用程序向输出中添加完整的 XML 事件。第 3 部分将详细讨论 StAX 序列化器 API。</P>
<P><A name=N100CF><SPAN class=smalltitle>为什么使用 StAX？</SPAN></A></P>
<P>开始学习一种新的处理 XML 的 API 之前，可能要问是否值得这样做。事实上，StAX 
所采用的基于拉的方法和其他方法相比有一些突出的优点。首先，不管使用哪种 API 
风格，都是应用程序调用读取器（解析器）而不是相反。通过保留解析过程的控制权，可以简化调用代码来准确地处理它预期的内容。或者发生意外时停止解析。此外，由于该方法不基于处理程序回调，应用程序不需要像使用 
SAX 那样模拟解析器的状态。</P>
<P>StAX 仍然保留了 SAX 相对于 DOM 的优点。通过把重心从结果对象模型转移到解析流本身，从理论上说应用程序能够处理无限的 XML 
流，因为事件固有的临时性，不会在内存中累积起来。对于那些使用 XML 作为消息传递协议而非表示文档内容的那些应用程序尤其重要，比如 Web 
服务或即时消息应用程序。比方说，如果只是将其转换成特定于应用程序的对象模型然后就将其丢弃，那么为 Web 服务路由器 servlet 提供一个 DOM 
就没有多少用处。使用 StAX 直接转化成应用程序模型效率更高。对于 Extensible Messaging and Presence 
Protocol（XMPP）客户机，根本不能使用 DOM，因为 XMPP 客户机/服务器流是随着用户输入的消息实时生成。等待流的关闭标签（以便最终建立 
DOM）就意味着等待整个会话结束。通过把 XML 作为一系列的事件来处理，应用程序能够以最合适的方式响应每个事件（比如显示收到的即时消息等等）。</P>
<P>由于其双向性，StAX 也支持链式处理，特别是在事件层上。接收事件（无论什么来源）的能力被封装在 
XMLEventConsumer（XMLEventWriter 的扩展）接口中。因此，可以模块化地编写应用程序从 
XMLEventReader（也是一个普通的迭代器，可以按迭代器处理）读取和处理 XML 事件、然后传递给事件消费者（如果需要可以进一步扩展处理链）。在第 2 
部分将看到，也可使用应用程序提供的筛选器（实现了 EventFilter 接口的类）来定制 XMLEventReader 或者使用 
EventReaderDelegate 修饰已有的 XMLEventReader。</P>
<P>总而言之，和 DOM 以及 SAX 相比，StAX 使应用程序更贴近底层的 XML。使用 StAX，应用程序不仅可以建立需要的对象模型（而不需要处理标准 
DOM），而且可以随时这样做，而不必等到解析器回调。</P>
<P>下一节将深入讨论基于指针的 API 以及如何有效地使用它处理 XML 流。</P><BR>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD><IMG alt="" src="blue_rule.gif" width="100%" 
height=1><BR><IMG border=0 alt="" src="c.gif" width=8 
height=6></TD></TR></TBODY></TABLE>
<TABLE class=no-print cellSpacing=0 cellPadding=0 align=right>
<TBODY>
<TR align=right>
<TD><IMG alt="" src="c.gif" width="100%" height=4><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD vAlign=middle><IMG border=0 alt="" 
src="u_bold.gif" width=16 height=16><BR></TD>
<TD vAlign=top align=right><A class=fbox 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><B>回页首</B></A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR>
<P><A name=N100E4><SPAN class=atitle>基于指针的 API</SPAN></A></P>
<P>如果使用基于指针的 API，应用程序通过在 XML 标记流中移动逻辑指针来处理 
XML。基于指针的解析器实质上是一个状态机，在事件的驱动下从一个良好定义的状态转移到另一个状态。这里的触发事件是随着应用程序使用适当的方法推动解析器在标记流中前进而解析出来的 
XML 标记。在每个状态，都可使用一组方法获得上一个事件的信息。一般来说，并非每个状态下都能使用所有的方法。</P>
<P>使用基于指针的方法，应用程序首先必须通过调用其 <CODE>createXMLStreamReader</CODE> 方法从 
<CODE>XMLInputFactory</CODE> 得到 
<CODE>XMLStreamReader</CODE>。该方法有多个版本，支持不同类型的输入。比方说，可以创建 
<CODE>XMLStreamReader</CODE> 解析 <CODE>plain 
java.io.InputStream</CODE>、<CODE>java.io.Reader</CODE> 或者 JAXP 
Source（<CODE>javax.xml.transform.Source</CODE>）。从理论上说，后一种办法很容易和其他 JAXP 技术交互，比如 
SAX 和 DOM。</P><BR><A name=N10110><B>清单 2. 创建 XMLStreamReader 解析 
InputStream</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
URL url = new URL(uri);
InputStream input = url.openStream();
XMLInputFactory factory = XMLInputFactory.newInstance();
XMLStreamReader r = factory.createXMLStreamReader(uri, input);
// process the stream
// ...
r.close();
input.close();
</PRE></TD></TR></TBODY></TABLE><BR>
<P><CODE>XMLStreamReader</CODE> 接口基本上定义了基于指针的 API（虽然标记常量在其超类型 
<CODE>XMLStreamConstants</CODE> 
接口中定义）。之所以称为基于指针，是因为读取器就像是底层标记流上的指针。应用程序可以沿着标记流向前推进指针并分析当前指针所在位置的标记。</P>
<P><CODE>XMLStreamReader</CODE> 提供了多种方法导航标记流。为了确定当前指针所指向的标记（或事件）的类型，应用程序可以调用 
<CODE>getEventType()</CODE>。该方法返回接口 <CODE>XMLStreamConstants</CODE> 
中定义的一个标记常量。移动到下一个标记，应用程序可以调用 <CODE>next()</CODE>。该方法也返回解析的标记的类型，如果接着调用 
<CODE>getEventType()</CODE> 则返回的值相同。只有当方法 <CODE>hasNext()</CODE> 返回 true 
时（就是说还有其他标记需要解析）才能调用该方法（以及其他移动读取器的方法）。</P><BR><A name=N10145><B>清单 3. 使用 
XMLStreamReader 处理 XML 的常用模式</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
// create an XMLStreamReader
XMLStreamReader r = ...;
try {
 int event = r.getEventType();
 while (true) {
 switch (event) {
 case XMLStreamConstants.START_DOCUMENT:
 // add cases for each event of interest
 // ...
 }

 if (!r.hasNext())
 break;
 
 event = r.next();
 }
} finally {
 r.close();
}
</PRE></TD></TR></TBODY></TABLE><BR>
<P>还与其他几种方法可以移动 <CODE>reader</CODE>。 <CODE>nextTag()</CODE> 
方法将跳过所有的空白、注释或处理指令，直到遇到 <CODE>START_ELEMENT</CODE> 或 
<CODE>END_ELEMENT</CODE>。该方法在解析只含元素的内容时很有用，如果在发现标记之前遇到非空白文本（不包括注释或处理指令），就会抛出异常。<CODE>getElementText()</CODE> 
方法返回元素的开始和关闭标签（即 <CODE>START_ELEMENT</CODE> 和 
<CODE>END_ELEMENT</CODE>）之间的所有文本内容。如果遇到嵌套的元素就会抛出异常。</P>
<P>请注意，这里的 “标记” 和 “事件” 可以互换使用。虽然基于指针的 API 
的文档说的是事件，但把输入源看成标记流很方便。而且不容易造成混乱，因为还有一整套基于事件的 
API（那里的事件是真正的对象）。不过，<CODE>XMLStreamReader</CODE> 
的事件本质上并非都是标记。比方说，<CODE>START_DOCUMENT</CODE> 和 <CODE>END_DOCUMENT</CODE> 
事件不需要对应的标记。前一个事件是解析开始之前发生，后者则在没有更多解析工作要做的时候发生（比如解析完成最后一个元素的关闭标签之后，读取器处于 
<CODE>END_ELEMENT</CODE> 状态，但是如果没有发现更多的标记需要解析，读取器就会切换到 <CODE>END_DOCUMENT</CODE> 
状态）。</P>
<P><A name=N10185><SPAN class=smalltitle>处理 XML 文档</SPAN></A></P>
<P>在每个解析器状态，应用程序都可通过可用的方法获得相关信息。比如，无论当前是什么类型的事件，<CODE>getNamespaceContext()</CODE> 
和 <CODE>getNamespaceURI()</CODE> 方法可以获得当前有效的名称空间上下文和名称空间 
URI。类似的，<CODE>getLocation()</CODE> 可以获得当前事件的位置信息。方法 <CODE>hasName()</CODE> 和 
<CODE>hasText()</CODE> 可以分别判断当前事件是否有名称（比如元素或属性）或文本（比如字符、注释或 CDATA）。方法 
<CODE>isStartElement()</CODE>、<CODE>isEndElement()</CODE>、<CODE>isCharacters()</CODE> 
和 <CODE>isWhiteSpace()</CODE> 可以方便地确定当前事件的性质。最后，方法 require(<CODE>int</CODE>, 
<CODE>String</CODE>, <CODE>String</CODE>) 
可以声明预期的解析器状态；除非当前事件是指定的类型，并且本地名和名称空间（如果给出的话）与当前事件匹配，否则该方法将抛出异常。</P><BR><A 
name=N101C2><B>清单 4. 如果当前事件是 START_ELEMENT 使用有关的属性方法</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
if (reader.getEventType() == XMLStreamConstants.START_ELEMENT) {
 System.out.println("Start Element: " + reader.getName());
 for(int i = 0, n = reader.getAttributeCount(); i &lt; n; ++i) {
 QName name = reader.getAttributeName(i);
 String value = reader.getAttributeValue(i);
 System.out.println("Attribute: " + name + "=" + value);
 }
}
</PRE></TD></TR></TBODY></TABLE><BR>
<P>创建之后，<CODE>XMLStreamReader</CODE> 将从 <CODE>START_DOCUMENT</CODE> 状态开始（即 
<CODE>getEventType()</CODE> 返回 
<CODE>START_DOCUMENT</CODE>）。处理标记的时候应考虑到这一点。和迭代器不同，不需要先移动指针（使用 
<CODE>next()</CODE>）来进入合法的状态。同样地，当读取器转换到最终状态 <CODE>END_DOCUMENT</CODE> 
之后，应用程序也不应再移动它。在这种状态下，<CODE>hasNext()</CODE> 方法将返回 false。</P>
<P><CODE>START_DOCUMENT</CODE> 事件提供了获取关于文档本身信息的方法，如 
<CODE>getEncoding()</CODE>、<CODE>getVersion()</CODE> 和 
<CODE>isStandalone()</CODE>。应用程序也可调用 <CODE>getProperty(String)</CODE> 
获得命名属性的值，不过一些属性仅在特定状态做了定义（比方说，如果当前事件是 DTD，则属性 
<CODE>javax.xml.stream.notations</CODE> 和 <CODE>javax.xml.stream.entities</CODE> 
分别返回所有的符号和实体声明）。</P>
<P>在 <CODE>START_ELEMENT</CODE> 和 <CODE>END_ELEMENT</CODE> 
事件中，可以使用和元素名称以及名称空间有关的方法（如 
<CODE>getName()</CODE>、<CODE>getLocalName()</CODE>、<CODE>getPrefix()</CODE> 和 
<CODE>getNamespaceXXX()</CODE>），在 <CODE>START_ELEMENT</CODE> 
事件中还可使用与属性有关的方法（<CODE>getAttributeXXX()</CODE>）。</P>
<P><CODE>ATTRIBUTE</CODE> 和 <CODE>NAMESPACE</CODE> 也被识别为独立的事件，虽然在解析 典型的 XML 
文档时不会用到。但是当 <CODE>ATTRIBUTE</CODE> 或 <CODE>NAMESPACE</CODE> 节点作为 XPath 
查询结果返回时可以使用。</P>
<P>和基于文本的事件（如 <CODE>CHARACTERS</CODE>、<CODE>CDATA</CODE>、<CODE>COMMENT</CODE> 和 
<CODE>SPACE</CODE>），可使用各种 <CODE>getTextXXX()</CODE> 方法取得文本。可以分别使用 
<CODE>getPITarget()</CODE> 和 <CODE>getPIData()</CODE> 检索 
<CODE>PROCESSING_INSTRUCTION</CODE> 的目标和数据。<CODE>ENTITY_REFERENCE</CODE> 和 
<CODE>DTD</CODE> 也支持 <CODE>getText()</CODE>，<CODE>ENTITY_REFERENCE</CODE> 还支持 
<CODE>getLocalName()</CODE>。</P>
<P>解析完成后，应用程序关闭读取器并释放解析过程中获得的资源。请注意这样并没有关闭底层的输入源。</P>
<P>清单 5 提供了一个完整的例子，使用基于指针的 API 处理 XML 文档。首先取得 <CODE>XMLInputFactory</CODE> 
的默认实例并创建一个 <CODE>XMLStreamReader</CODE> 
解析给定的输入流。然后不断检查读取器的状态，根据当前事件的类型报告某些信息（比如在 <CODE>START_ELEMENT</CODE> 
状态下报告元素名及元素属性）。最后，遇到 <CODE>END_DOCUMENT</CODE> 时关闭读取器。</P><BR><A 
name=N1028F><B>清单 5. 使用 XMLStreamReader 解析 XML 文档的完整例子</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
XMLInputFactory factory = XMLInputFactory.newInstance();
XMLStreamReader r = factory.createXMLStreamReader(input);
try {
 int event = r.getEventType();
 while (true) {
 switch (event) {
 case XMLStreamConstants.START_DOCUMENT:
 out.println("Start Document.");
 break;
 case XMLStreamConstants.START_ELEMENT:
 out.println("Start Element: " + r.getName());
 for(int i = 0, n = r.getAttributeCount(); i &lt; n; ++i)
 out.println("Attribute: " + r.getAttributeName(i) 
 + "=" + r.getAttributeValue(i));
 
 break;
 case XMLStreamConstants.CHARACTERS:
 if (r.isWhiteSpace())
 break;
 
 out.println("Text: " + r.getText());
 break;
 case XMLStreamConstants.END_ELEMENT:
 out.println("End Element:" + r.getName());
 break;
 case XMLStreamConstants.END_DOCUMENT:
 out.println("End Document.");
 break;
 }
 
 if (!r.hasNext())
 break;

 event = r.next();
 }
} finally {
 r.close();
}
</PRE></TD></TR></TBODY></TABLE><BR>
<P><A name=N10299><SPAN class=smalltitle>XMLStreamReader 的高级用法</SPAN></A></P>
<P>通过调用 <CODE>XMLInputFactory</CODE> 的带有基本读取器的 <CODE>createFilteredReader</CODE> 
方法和一个应用程序定义的筛选器（即实现 <CODE>StreamFilter</CODE> 的类实例），可以创建筛选过的 
<CODE>XMLStreamReader</CODE>。导航筛选过的读取器时，读取器每次移动到下一个标记之前都会询问筛选器。如果筛选器认可了当前事件，就将其公开给筛选过的读取器。否则跳过这个标记并检查下一个，依此类推。这种方法可以让开发人员创建一个仅处理解析内容子集的基于指针的 
XML 处理程序，并与针对不同的扩展的内容模型的筛选器结合使用。</P>
<P>执行更复杂的流操作，可以创建 <CODE>StreamReaderDelegate</CODE> 的子类并重写合适的方法。然后使用这个子类的实例包装基本 
<CODE>XMLStreamReader</CODE>，从而为应用程序提供一个修改过的基本 XML 流的视图。可通过这种技术对 XML 
流执行简单的转换，比如筛掉或者替换特定的标记，甚至增加新的标记。</P>
<P>清单 6 用定制的 <CODE>StreamReaderDelegate</CODE> 包装了基本 
<CODE>XMLStreamReader</CODE>，重写了 <CODE>next()</CODE> 方法来跳过 <CODE>COMMENT</CODE> 
和 <CODE>PROCESSING_INSTRUCTION</CODE> 事件。使用该读取器时，应用程序不用担心会遇到这种类型的标记。</P><BR><A 
name=N102DB><B>清单 6. 使用定制的 StreamReaderDelegate 筛选注释和处理指令</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
URL url = new URL(uri);
InputStream input = url.openStream();

XMLInputFactory f = XMLInputFactory.newInstance();
XMLStreamReader r = f.createXMLStreamReader(uri, input);
XMLStreamReader fr = new StreamReaderDelegate(r) {
 public int next() throws XMLStreamException {
 while (true) {
 int event = super.next();
 switch (event) {
 case XMLStreamConstants.COMMENT:
 case XMLStreamConstants.PROCESSING_INSTRUCTION:
 continue;
 default:
 return event;
 }
 }
 }
};

try {
 int event = fr.getEventType();
 while (true) {
 switch (event) {
 case XMLStreamConstants.COMMENT:
 case XMLStreamConstants.PROCESSING_INSTRUCTION:
 // this should never happen
 throw new IllegalStateException("Filter failed!");
 default:
 // process XML normally
 }

 if (!fr.hasNext())
 break;

 event = fr.next();
 }
} finally {
 fr.close();
}

input.close();
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD><IMG alt="" src="blue_rule.gif" width="100%" 
height=1><BR><IMG border=0 alt="" src="c.gif" width=8 
height=6></TD></TR></TBODY></TABLE>
<TABLE class=no-print cellSpacing=0 cellPadding=0 align=right>
<TBODY>
<TR align=right>
<TD><IMG alt="" src="c.gif" width="100%" height=4><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD vAlign=middle><IMG border=0 alt="" 
src="u_bold.gif" width=16 height=16><BR></TD>
<TD vAlign=top align=right><A class=fbox 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><B>回页首</B></A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR>
<P><A name=N102E5><SPAN class=atitle>基于指针处理之外的其他技术</SPAN></A></P>
<P>可以看到，基于指针的 API 
主要是为了提高效率。所有的状态信息可以直接从流读取器获得，不需要创建额外的对象。非常适用于性能和低内存占用至关重要的应用程序。</P>
<P>人们早就认识到了拉式 XML 解析的好处。事实上，StAX 本身源于一种称为 <I>XML Pull Parsing</I> 的方法。XML Pull 
Parser API 类似于 StAX 所提供的基于指针的 
API，可以通过分析解析器的状态获得上一个解析事件的信息，然后移动到下一个，依此类推。但没有提供基于事件迭代器的 
API。这是一种非常轻型的方法，特别适合资源受限的环境，比如 J2ME。但是，很少有实现提供企业级特性如验证，因此 XML Pull 一直未受到企业 Java 
开发人员的关注。</P>
<P>基于以往拉式解析器实现的经验，StAX 的创建者选择了在基于指针的 API 之外增加一种面向对象的 API。虽然 
<CODE>XMLEventReader</CODE> 
接口看起来似乎很简单，但是基于事件迭代器的方法具有一个基于指针的方法不具备的重要优点。通过将解析器事件变成一级对象，从而让应用程序可以采用面向对象的方式处理它们。这样做有助于模块化和不同应用程序组件之间的代码重用。</P><BR><A 
name=N102FF><B>清单 7. 使用 StAX XMLEventReader 解析 XML</B></A><BR>
<TABLE cellSpacing=0 cellPadding=0 width=100 border=0>
<TBODY>
<TR>
<TD class=code-outline><PRE class=displaycode>
XMLInputFactory inputFactory = XMLInputFactory.newInstance();
XMLEventReader reader = inputFactory.createXMLEventReader(input);
try {
 while (reader.hasNext()) {
 XMLEvent e = reader.nextEvent();
 if (e.isCharacters() &amp;&amp; ((Characters) e).isWhiteSpace())
 continue;
 
 out.println(e);
 }
} finally {
 reader.close();
}
</PRE></TD></TR></TBODY></TABLE><BR><BR>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD><IMG alt="" src="blue_rule.gif" width="100%" 
height=1><BR><IMG border=0 alt="" src="c.gif" width=8 
height=6></TD></TR></TBODY></TABLE>
<TABLE class=no-print cellSpacing=0 cellPadding=0 align=right>
<TBODY>
<TR align=right>
<TD><IMG alt="" src="c.gif" width="100%" height=4><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD vAlign=middle><IMG border=0 alt="" 
src="u_bold.gif" width=16 height=16><BR></TD>
<TD vAlign=top align=right><A class=fbox 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><B>回页首</B></A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR>
<P><A name=N10309><SPAN class=atitle>结束语</SPAN></A></P>
<P>本文介绍了 StAX 及其基于指针的 API。第 2 部分将深入讨论事件迭代器 API。</P><BR><BR>
<P><A name=resources><SPAN class=atitle>参考资料 </SPAN></A></P><B>学习</B><BR>
<UL>
<LI>您可以参阅本文在 developerWorks 全球网站上的 <A 
href="http://www.ibm.com/developerworks/xml/library/x-stax1.html?S_TACT=105AGX52&amp;S_CMP=cn-a-x" 
target=_blank>英文原文</A>。<BR><BR>
<LI><A href="http://jcp.org/en/jsr/detail?id=173">JSR 173: Streaming API for 
XML</A>：阅读这份 Java Specification Request，它提出了可拉式解析 XML 的基于 Java 的 API。<BR><BR>
<LI><A href="http://www.xmlpull.org/index.shtml">XML Pull 
Parsing</A>：这个站点致力于推广和培训拉式 XML 解析。<BR><BR>
<LI><A href="http://dev2dev.bea.com/xml/stax.html">BEA Dev2Dev Online: 
StAX</A>：BEA 关于 StAX 的网页，包括 WebLogic StAX 实现的链接。<BR><BR>
<LI><A 
href="http://www.ibm.com/developerworks/edu/x-dw-xml-i.html?S_TACT=105AGX52&amp;S_CMP=cn-a-x">XML 
programming in Java technology, Part 1</A>（Doug Tidwell，developerWorks，2004 年 1 
月）：获得关于使用 Java 进行 XML 编程的教程，内容包括 XML 的通用 API，以及如何解析、创建、操作和转换 XML 文档。<BR><BR>
<LI><A href="http://www.ibm.com/developerworks/cn/xml/x-jaxp/index.html">JAXP 
全面介绍，第 1 部分</A>（Brett McLaughlin，developerWorks，2005 年 6 月）：了解如何使用 JAXP API 
的解析和验证特性。<BR><BR>
<LI><A href="http://www.ibm.com/developerworks/cn/xml/x-tipstx/index.html">技巧: 
使用 XML 流解析器</A>（Berthold Daum，developerWorks，2003 年 11 月）：这篇技巧介绍了如何利用 StAX 
提供的流解析器高效解析 XML。<BR><BR>
<LI><A href="http://www.ibm.com/developerworks/cn/xml/x-tipstx4/index.html">技巧: 
使用 StAX 编写 XML 文档</A>（Berthold Daum，developerWorks，2004 年 1 月）：使用 StAX 序列化器 XML 
—— 解析 XML 文档并将 XML 文档写入一个输出流。<BR><BR>
<LI><A 
href="http://www.ibm.com/developerworks/xml/library/wa-xslt/?S_TACT=105AGX52&amp;S_CMP=cn-a-x">An 
XSLT style sheet and an XML dictionary approach to 
internationalization</A>（Laura Menke，developerWorks，2001 年 4 月）：阅读 XSLT 
用于解决实际问题的例子：通过词典驱动的方法对网页实现动态国际化，更新站点内容时减少需要编辑的文件。<BR><BR>
<LI><A href="http://www.ibm.com/developerworks/cn/xml/x-xslang/">XSLT 
处理程序是如何工作的</A>（Beno?t Marchal，developerWorks，2004 年 4 月）：了解 XSLT 处理程序的有关理论，提高 
XSLT 编程效率。<BR><BR>
<LI><A href="http://www.ibm.com/developerworks/cn/xml/x-xslt20pt1.html">准备从 XSLT 
1.0 升级到 2.0，第 1 部分: XSLT 的改进</A>（David Marston 和 Joanne Tong，developerWorks，2006 
年 11 月）：对 XSLT 2.0 的主要特性和 XSLT 1.0 （目前使用的版本）的不足之处进行了介绍。<BR><BR>
<LI><A 
href="http://www.ibm.com/certify/certs/xmsdreltop.shtml?S_TACT=105AGX52&amp;S_CMP=cn-a-x">IBM 
XML 认证</A>：了解如何才能成为一名 IBM 认证的 XML 及相关技术的开发人员。<BR><BR>
<LI><A 
href="http://www.ibm.com/developerworks/cn/xml/library/technical/xml.html">XML 
技术库</A>：developerWorks 中国网站 XML 专区提供了大量技术文章、技巧、教程、标准以及 IBM 红皮书。<BR><BR>
<LI><A 
href="http://www.ibm.com/developerworks/cn/offers/techbriefings/">developerWorks 
技术活动</A> 和 <A 
href="http://www.ibm.com/developerworks/offers/techbriefings/events.html?S_TACT=105AGX52&amp;S_CMP=cn-a-l">网络广播</A>：随时关注技术的最新进展。<BR><BR>
<LI>通过 <A href="http://www.ibm.com/developerworks/cn/xml">developerWorks 中国网站 
XML 专区</A> 了解 XML 的方方面面。 </LI></UL><BR><B>获得产品和技术</B><BR>
<UL>
<LI>Sun 的 <A href="https://jaxp.dev.java.net/">JAXP 项目页</A>：可以找到各种 JAXP 
版本的下载链接。<BR><BR></LI></UL><BR><B>讨论</B><BR>
<UL>
<LI><A 
href="http://www.ibm.com/developerworks/community/">参与论坛讨论</A>。</LI></UL><BR><BR>
<P><A name=author><SPAN class=atitle>关于作者</SPAN></A></P>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD colSpan=3><IMG alt="" src="c.gif" width="100%" 
height=5></TD></TR>
<TR vAlign=top align=left>
<TD>
<P></P></TD>
<TD><IMG alt="" src="c.gif" width=4 height=5></TD>
<TD width="100%">
<P>Peter Nehrer 是一名专长于基于 Eclipse 的企业解决方案和 Java EE 应用程序的软件顾问。他创建了 Ecliptical 
Software Inc.，并且是一些和 Eclipse 
有关的开放源码项目的贡献者。他拥有从马萨诸塞州大学阿默斯特校区获得的计算机科学硕士学位。</P></TD></TR></TBODY></TABLE><BR><BR><BR>
<P class=no-print><SPAN class=atitle><A name=rate>对本文的评价</A></SPAN></P><SPAN 
class=no-print>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR vAlign=top>
<TD>
<FORM action=https://www.ibm.com/developerworks/secure/cnratings.jsp 
method=get><INPUT type=hidden 
value="使用 StAX 解析 XML，第 1 部分: Streaming API for XML (StAX) 简介" 
name=ArticleTitle><INPUT type=hidden value="XML, Java technology" 
name=Zone><INPUT type=hidden 
value=http://www.ibm.com/developerworks/cn/thankyou/ name=RedirectURL><INPUT 
type=hidden value=china name=localsite>
<SCRIPT language=javascript>document.write('<input type="hidden" name="url" value="'+location.href+'" />');</SCRIPT>
<INPUT type=hidden 
value=http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn name=url>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD><IMG border=0 alt="" src="c.gif" width=100 
height=8></TD></TR>
<TR vAlign=top>
<TD><INPUT type=radio value=1 name=Rating>太差！ (1)</TD></TR>
<TR vAlign=top>
<TD><INPUT type=radio value=2 name=Rating>需提高 (2)</TD></TR>
<TR vAlign=top>
<TD><INPUT type=radio value=3 name=Rating>一般；尚可 (3)</TD></TR>
<TR vAlign=top>
<TD><INPUT type=radio value=4 name=Rating>好文章 (4)</TD></TR>
<TR vAlign=top>
<TD><INPUT type=radio value=5 
name=Rating>真棒！(5)</TD></TR></TBODY></TABLE><BR><B>将您的建议发给我们或者通过参加讨论与其他人分享您的想法.</B><BR><TEXTAREA id=Comments wrap=virtual rows=5 cols=60 name=Comments>&nbsp;</TEXTAREA><BR><BR><INPUT type=submit value=反馈意见></FORM></TD></TR>
<TR vAlign=top>
<TD bgColor=#ffffff><IMG border=0 alt="" src="c.gif" width=100 
height=8></TD></TR></TBODY></TABLE></SPAN><SPAN class=no-print>
<TABLE cellSpacing=0 cellPadding=0 align=right>
<TBODY>
<TR align=right>
<TD><IMG alt="" src="c.gif" width="100%" height=8><BR>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD vAlign=middle><IMG border=0 alt="" 
src="u_bold.gif" width=16 height=16><BR></TD>
<TD vAlign=top align=right><A class=fbox 
href="http://www.ibm.com/developerworks/cn/xml/x-stax1.html?ca=drs-cn#main"><B>回页首</B></A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR></SPAN></TD>
<TD width=10><IMG alt="" src="c.gif" width=10 
height=1></TD></TR></TBODY></TABLE><SPAN class=small>IBM 公司保留在 developerWorks 
网站上发表的内容的著作权。未经IBM公司或原始作者的书面明确许可，请勿转载。如果您希望转载，请通过 <A 
href="https://www.ibm.com/developerworks/secure/reprintreq.jsp?domain=dwchina">提交转载请求表单</A> 
联系我们的编辑团队。</SPAN></TD></TR></TBODY></TABLE><!--FOOTER_BEGIN--><BR>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
<TBODY>
<TR>
<TD class=bbg height=19>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD><SPAN class=spacer>&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><A class=mainlink 
href="index.shtml">关于 IBM</A></TD>
<TD class=footer-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=mainlink 
href="index.shtml">隐私条约</A></TD>
<TD class=footer-divider width=27>&nbsp;&nbsp;&nbsp;&nbsp;</TD>
<TD><A class=mainlink href="http://www.ibm.com/contact/">联系 
IBM</A></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P>
<SCRIPT language=JavaScript1.2 src="stats.js" 
type=text/javascript></SCRIPT>
<NOSCRIPT></NOSCRIPT><!--FOOTER_END--><!--XSLT stylesheet used to transform this file:  dw-document-html-5.6.xsl--><!--EndFragment--></P>
<P>&nbsp;</P></BODY>
</script>